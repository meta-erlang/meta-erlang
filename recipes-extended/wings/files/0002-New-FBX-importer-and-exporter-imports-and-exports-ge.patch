From 20f30cf621d322a0ee167cc86f92acdb7ea06f88 Mon Sep 17 00:00:00 2001
From: Edward Blake <mail@edwardlblake.com>
Date: Tue, 29 Aug 2023 08:03:02 -0400
Subject: [PATCH] New FBX importer and exporter, imports and exports
 geometries, UVs, materials, textures.

NOTE: New FBX importer/exporter.
---
 plugins_src/import_export/Makefile         |    2 +
 plugins_src/import_export/fbx_p_import.erl | 2110 ++++++++++++++++++++
 plugins_src/import_export/wpc_fbx_p.erl    | 1754 ++++++++++++++++
 3 files changed, 3866 insertions(+)
 create mode 100644 plugins_src/import_export/fbx_p_import.erl
 create mode 100644 plugins_src/import_export/wpc_fbx_p.erl

diff --git a/plugins_src/import_export/Makefile b/plugins_src/import_export/Makefile
index ca7509cd..478aca02 100644
--- a/plugins_src/import_export/Makefile
+++ b/plugins_src/import_export/Makefile
@@ -34,6 +34,8 @@ MODULES= \
 	wpc_bzw \
 	wpc_collada \
 	collada_import \
+	wpc_fbx_p \
+	fbx_p_import \
 	wpc_gltf \
 	wpc_hlines \
 	wpc_jscad \
diff --git a/plugins_src/import_export/fbx_p_import.erl b/plugins_src/import_export/fbx_p_import.erl
new file mode 100644
index 00000000..a72c1d5f
--- /dev/null
+++ b/plugins_src/import_export/fbx_p_import.erl
@@ -0,0 +1,2110 @@
+%%
+%%  fbx_p_import.erl --
+%%
+%%     FBX file import part of the wpc_fbx_p plugin.
+%%
+%%  Copyright (c) 2023 Edward Blake
+%%
+%%  See the file "license.terms" for information on usage and redistribution
+%%  of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+%%
+%%     $Id$
+%%
+
+-module(fbx_p_import).
+-export([do_import/2]).
+-export([t_bin/0]).
+-export([trav/1]).
+-include_lib("wings/e3d/e3d.hrl").
+-include_lib("wings/e3d/e3d_image.hrl").
+-include_lib("wings/intl_tools/wings_intl.hrl").
+
+-define(WPC_FBX, wpc_fbx_p).
+
+%%%
+%%% Import.
+%%%
+
+do_import(Ask, _St) when is_atom(Ask) ->
+    Dialog = [
+    ] ++ common_mesh_options(import),
+    wpa:dialog(Ask, ?__(1,"FBX Import Options"), Dialog,
+           fun(Res) ->
+               {file,{import,{fbx_model,Res}}}
+           end);
+do_import(Attr, St) ->
+    wpa:import(props(), import_fun(Attr), St).
+
+set_pref(KeyVals) ->
+    wpa:pref_set(?WPC_FBX, KeyVals).
+
+props() ->
+    [{ext,".fbx"},{ext_desc,?__(1,"FBX Model File")}].
+
+common_mesh_options(Type) ->
+    [wpa:dialog_template(?WPC_FBX, Type, [include_colors])].
+
+import_transform(E3dFile, KeyVals) ->
+    Mat = wpa:import_matrix(KeyVals),
+    e3d_file:transform(E3dFile, Mat).
+
+
+import_fun(Attr) ->
+    fun(Filename) ->
+        set_pref(Attr),
+        FilenameExt = filename:extension(Filename),
+        FBXPath = filename:dirname(Filename),
+        _ObjName = filename:basename(Filename,FilenameExt),
+        
+        {Models,MatL} = read_fbx_to_models(Filename),
+        Objs = lists:append([from_fbx_model_to_obj(M) || M <- Models]),
+        Mats = [from_fbx_material(Mt, FBXPath) || Mt <- MatL],
+        
+        {ok, import_transform(#e3d_file{objs=Objs,mat=Mats}, Attr)}
+    end.
+    
+%% FBX models seem to be normally 0 ... 100.0
+-define(FBX_SCALE, 0.01).
+
+rescale_model_import(Vertices0, L) ->
+    case proplists:get_value(prop, L, []) of
+        Props ->
+            {lclscaling,XScl,YScl,ZScl} =
+                proplists:get_value(<<"Lcl Scaling">>, Props,
+                    {lclscaling,100.0,100.0,100.0}),
+            Vertices = 
+                [{X*XScl*?FBX_SCALE,Y*YScl*?FBX_SCALE,Z*ZScl*?FBX_SCALE}
+                  || {X,Y,Z} <- Vertices0],
+            Vertices
+    end.
+
+reposition_model_import(Vertices0, L) ->
+    case proplists:get_value(prop, L, []) of
+        Props ->
+            {lcltranslation,XTrl,YTrl,ZTrl} =
+                proplists:get_value(<<"Lcl Translation">>, Props,
+                    {lcltranslation,0.0,0.0,0.0}),
+            Vertices = 
+                [{float(X+XTrl),float(Y+YTrl),float(Z+ZTrl)}
+                  || {X,Y,Z} <- Vertices0],
+            Vertices
+    end.
+
+rotate_model_import(Vertices0, L) ->
+    case proplists:get_value(prop, L, []) of
+        Props ->
+            {lclrotation,XAng,YAng,ZAng} =
+                proplists:get_value(<<"Lcl Rotation">>, Props,
+                    {lclrotation,0.0,0.0,0.0}),
+            Mat = e3d_mat:mul(
+                e3d_mat:mul(
+                    rotate_mat(1.0, 0.0, 0.0, XAng),
+                    rotate_mat(0.0, 1.0, 0.0, YAng)),
+                rotate_mat(0.0, 0.0, 1.0, ZAng)),
+            Vertices = 
+                [e3d_mat:mul_point(Mat, VPos)
+                  || VPos <- Vertices0],
+            Vertices
+    end.
+
+rotate_mat(XA, YA, ZA, Ang) ->
+    e3d_mat:rotate(float(Ang), {float(XA), float(YA), float(ZA)}).
+
+
+from_fbx_model_to_obj({{model,_AtomName},L}) ->
+    MatNames = lists:reverse([Mt || {{mat,Mt},mat} <- L]), %% Order of materials are reversed
+    case proplists:get_value(geom, L, none) of
+        none ->
+            [];
+        L1 ->
+            Vertices_0 = proplists:get_value(vertices, L1, []),
+            Vertices_1 = rescale_model_import(Vertices_0, L),
+            Vertices_2 = reposition_model_import(Vertices_1, L),
+            Vertices = rotate_model_import(Vertices_2, L),
+            VtxList = proplists:get_value(vtxindex, L1, []),
+            Efs_0 = [
+                    #e3d_face{ vs=IdxL, mat=[default] }
+                    || IdxL <- VtxList ],
+            {Efs_1, Tx} = set_uv_fs_list(Efs_0, Vertices, L1),
+            {Efs_2, Ns} = set_ns_fs_list(Efs_1, Vertices, L1),
+            HEs = set_he_list(VtxList, L1),
+            Efs = set_mtl_fs_list(Efs_2, L1, MatNames),
+            Mesh = #e3d_mesh{
+                type=polygon,
+                vs=Vertices,
+                fs=Efs,
+                tx=Tx,
+                ns=Ns,
+                he=HEs
+            },
+            [#e3d_object{obj=Mesh}]
+    end;
+from_fbx_model_to_obj(_) ->
+    [].
+
+%% Set material to e3d_face
+%%
+set_mtl_fs_list(Efs_0, _L1, [])
+  when is_list(Efs_0) ->
+    Efs_0;
+set_mtl_fs_list(Efs_0, L1, MatNames)
+  when is_list(Efs_0), is_list(L1), is_list(MatNames) ->
+    case proplists:get_value(layerelementmaterial, L1, none) of
+        none ->
+            set_mtl_fs_list_1(Efs_0, [0], MatNames);
+        [] ->
+            set_mtl_fs_list_1(Efs_0, [0], MatNames);
+        LEM when is_list(LEM) ->
+            case proplists:get_value(refinfotype, LEM, none) of
+                <<"IndexToDirect">> ->
+                    case proplists:get_value(mappinginfotype, LEM, none) of
+                        <<"ByPolygon">> ->
+                            ML = proplists:get_value(materials, LEM, []),
+                            set_mtl_fs_list_1(Efs_0, ML, MatNames);
+                        <<"AllSame">> -> %% The same function can be used.
+                            ML = proplists:get_value(materials, LEM, []),
+                            set_mtl_fs_list_1(Efs_0, ML, MatNames)
+                    end
+            end
+    end.
+
+set_mtl_fs_list_1(L1, [], _MatNames) ->
+    L1;
+set_mtl_fs_list_1(L1, ML, MatNames) ->
+    set_mtl_fs_list_1(L1, ML, MatNames, []).
+set_mtl_fs_list_1([#e3d_face{}=F|R], [MLI]=ML, MatNames, OL) ->
+    MName = lists:nth(MLI+1, MatNames),
+    set_mtl_fs_list_1(R, ML, MatNames, [F#e3d_face{mat=[MName]}|OL]);
+set_mtl_fs_list_1([#e3d_face{}=F|R], [MLI|ML], MatNames, OL) ->
+    MName = lists:nth(MLI+1, MatNames),
+    set_mtl_fs_list_1(R, ML, MatNames, [F#e3d_face{mat=[MName]}|OL]);
+set_mtl_fs_list_1([], [_], _MatNames, OL) ->
+    lists:reverse(OL).
+
+
+%% Set UV to e3d_face
+%%
+set_uv_fs_list(Efs_0, Vertices, L1)
+  when is_list(Efs_0), is_list(Vertices), is_list(L1) ->
+    case proplists:get_value(layerelementuv, L1, none) of
+        none ->
+            {Efs_0, []};
+        [] ->
+            {Efs_0, []};
+        LEM when is_list(LEM) ->
+            case proplists:get_value(refinfotype, LEM, none) of
+                <<"IndexToDirect">> ->
+                    case proplists:get_value(mappinginfotype, LEM, none) of
+                        <<"ByPolygonVertex">> ->
+                            TxTup = proplists:get_value(uv, LEM, []),
+                            ML = proplists:get_value(uvindex, LEM, []),
+                            {set_uv_fs_list_1(Efs_0, ML), set_uv_float(TxTup)}
+                    end;
+                <<"Direct">> ->
+                    case proplists:get_value(mappinginfotype, LEM, none) of
+                        <<"ByPolygonVertex">> ->
+                            TxTup = proplists:get_value(uv, LEM, []),
+                            ML = lists:seq(0,length(TxTup)-1),
+                            {set_uv_fs_list_1(Efs_0, ML), set_uv_float(TxTup)};
+                        <<"ByVertice">> ->
+                            TxTup = proplists:get_value(uv, LEM, []),
+                            set_uv_fs_list_byv(Efs_0, set_uv_float(TxTup), Vertices)
+                    end
+            end
+    end.
+set_uv_float(LTup) ->
+    lists:map(fun({U,V}) -> {float(U),float(V)} end, LTup).
+
+set_uv_fs_list_1(Efs_0, []) ->
+    Efs_0;
+set_uv_fs_list_1(Efs_0, UVL) ->
+    set_uv_fs_list_1(Efs_0, UVL, []).
+set_uv_fs_list_1([#e3d_face{}=F|R], UVL, OL) ->
+    {TxI1, UVL_1} = set_uv_fs_list_2(F, UVL),
+    set_uv_fs_list_1(R, UVL_1, [F#e3d_face{tx=TxI1}|OL]);
+set_uv_fs_list_1([], [], OL) ->
+    lists:reverse(OL).
+
+set_uv_fs_list_2(#e3d_face{vs=Vs}, UVL) ->
+    set_uv_fs_list_2(Vs, UVL, []).
+set_uv_fs_list_2([_|R], [Idx|UVL], OL) ->
+    set_uv_fs_list_2(R, UVL, [Idx|OL]);
+set_uv_fs_list_2([], UVL, OL) ->
+    {lists:reverse(OL), UVL}.
+
+%% ByVertice
+set_uv_fs_list_byv(Efs_0, [], _) ->
+    {Efs_0, []};
+set_uv_fs_list_byv(Efs_0, L1, L2)
+  when length(L1) < length(L2) ->
+    set_uv_fs_list_byv(Efs_0,
+        L1 ++ [{0.0,0.0} || _ <- lists:seq(1, length(L2)-length(L1))],
+        L2);
+set_uv_fs_list_byv(Efs_0, L1, L2)
+  when length(L1) > length(L2) ->
+    set_uv_fs_list_byv(Efs_0, lists:sublist(L1,length(L2)), L2);
+set_uv_fs_list_byv(Efs_0, L1, _) ->
+    {set_uv_fs_list_byv_1(Efs_0, []), L1}.
+set_uv_fs_list_byv_1([#e3d_face{vs=Vs}=F|R], OL) ->
+    set_uv_fs_list_byv_1(R, [F#e3d_face{tx=Vs}|OL]);
+set_uv_fs_list_byv_1([], OL) ->
+    lists:reverse(OL).
+
+
+%% Set Normals to e3d_face
+%%
+set_ns_fs_list(Efs_0, Vertices, L1)
+  when is_list(Efs_0), is_list(Vertices), is_list(L1) ->
+    case proplists:get_value(layerelementnormal, L1, none) of
+        none ->
+            {Efs_0, []};
+        [] ->
+            {Efs_0, []};
+        LEM when is_list(LEM) ->
+            case proplists:get_value(refinfotype, LEM, none) of
+                <<"IndexToDirect">> ->
+                    case proplists:get_value(mappinginfotype, LEM, none) of
+                        <<"ByPolygonVertex">> ->
+                            TxTup = proplists:get_value(normals, LEM, []),
+                            ML = proplists:get_value(normalsindex, LEM, []),
+                            {set_ns_fs_list_1(Efs_0, ML), set_ns_float(TxTup)};
+                        _ ->
+                            {Efs_0, []}
+                    end;
+                <<"Direct">> ->
+                    case proplists:get_value(mappinginfotype, LEM, none) of
+                        <<"ByPolygonVertex">> ->
+                            TxTup = proplists:get_value(normals, LEM, []),
+                            ML = lists:seq(0,length(TxTup)-1),
+                            {set_ns_fs_list_1(Efs_0, ML), set_ns_float(TxTup)};
+                        <<"ByVertice">> ->
+                            TxTup = proplists:get_value(normals, LEM, []),
+                            set_ns_fs_list_byv(Efs_0, set_ns_float(TxTup), Vertices);
+                        _ ->
+                            {Efs_0, []}
+                    end;
+                _ ->
+                    {Efs_0, []}
+            end
+    end.
+set_ns_float(LTup) ->
+    lists:map(fun ({X,Y,Z}) -> {float(X),float(Y),float(Z)} end, LTup).
+
+
+set_ns_fs_list_1(Efs_0, []) ->
+    Efs_0;
+set_ns_fs_list_1(Efs_0, NsL) ->
+    set_ns_fs_list_1(Efs_0, NsL, []).
+set_ns_fs_list_1([#e3d_face{}=F|R], NsL, OL) ->
+    {TxI1, NsL_1} = set_ns_fs_list_2(F, NsL),
+    set_ns_fs_list_1(R, NsL_1, [F#e3d_face{ns=TxI1}|OL]);
+set_ns_fs_list_1([], [], OL) ->
+    lists:reverse(OL).
+
+set_ns_fs_list_2(#e3d_face{vs=Vs}, NsL) ->
+    set_ns_fs_list_2(Vs, NsL, []).
+set_ns_fs_list_2([_|R], [Idx|NsL], OL) ->
+    set_ns_fs_list_2(R, NsL, [Idx|OL]);
+set_ns_fs_list_2([], NsL, OL) ->
+    {lists:reverse(OL), NsL}.
+
+%% ByVertice
+set_ns_fs_list_byv(Efs_0, [], _) ->
+    {Efs_0, []};
+set_ns_fs_list_byv(Efs_0, L1, L2)
+  when length(L1) < length(L2) ->
+    set_ns_fs_list_byv(Efs_0,
+        L1 ++ [{0.0,0.0,0.0} || _ <- lists:seq(1,length(L2)-length(L1))],
+        L2);
+set_ns_fs_list_byv(Efs_0, L1, L2)
+  when length(L1) > length(L2) ->
+    set_ns_fs_list_byv(Efs_0, lists:sublist(L1,length(L2)), L2);
+set_ns_fs_list_byv(Efs_0, L1, _) ->
+    {set_ns_fs_list_byv_1(Efs_0, []), L1}.
+set_ns_fs_list_byv_1([#e3d_face{vs=Vs}=F|R], OL) ->
+    set_ns_fs_list_byv_1(R, [F#e3d_face{ns=Vs}|OL]);
+set_ns_fs_list_byv_1([], OL) ->
+    lists:reverse(OL).
+
+
+
+%% Set hard edges to e3d_face
+%%
+set_he_list(VtxList, L1)
+  when is_list(VtxList), is_list(L1) ->
+    case proplists:get_value(layerelementsmoothing, L1, none) of
+        none ->
+            [];
+        [] ->
+            [];
+        LEM when is_list(LEM) ->
+            case proplists:get_value(refinfotype, LEM, none) of
+                <<"Direct">> ->
+                    case proplists:get_value(mappinginfotype, LEM, none) of
+                        <<"ByEdge">> ->
+                            EdgeL = proplists:get_value(edges, L1, none),
+                            EdgeS = proplists:get_value(smoothing, LEM, []),
+                            set_he_list_1(VtxList, zip_edge_list(EdgeL, EdgeS));
+                        <<"ByPolygon">> ->
+                            PlyS = proplists:get_value(smoothing, LEM, []),
+                            set_he_list_ply(VtxList, PlyS);
+                        _ ->
+                            []
+                    end;
+                _ ->
+                    []
+            end
+    end.
+zip_edge_list(_, []) ->
+    [];
+zip_edge_list(none, B) ->
+    {none, B};
+zip_edge_list(A, B) ->
+    zip_edge_list(A, B, []).
+zip_edge_list([A|EdgeL], [B], OL) ->
+    zip_edge_list(EdgeL, [B], [{A,B}|OL]);
+zip_edge_list([A|EdgeL], [B|EdgeS], OL) ->
+    zip_edge_list(EdgeL, EdgeS, [{A,B}|OL]);
+zip_edge_list([], [_], OL) ->
+    lists:reverse(OL).
+uidx_to_edge(Idx,UE) ->
+    case gb_trees:lookup(Idx, UE) of
+        {value, E} -> E
+    end.
+set_he_list_1(VtxList, {none, EL}) ->
+    UE = [U || {_,U} <- set_he_uedges(VtxList)],
+    [E || {E,On} <- lists:zip(UE,EL), On =:= 0];
+set_he_list_1(VtxList, EL) ->
+    UE = gb_trees:from_orddict(orddict:from_list(set_he_uedges(VtxList))),
+    [uidx_to_edge(VN,UE) || {VN,On} <- EL, On =:= 0].
+%% List of unique edges
+set_he_uedges(PolygonVIdx) ->
+    set_he_uedges(PolygonVIdx, []).
+set_he_uedges([[C|[B2|_]=L]|R], OL) ->
+    OL_1 = set_he_uedges_1(C, L, [{C,B2}|OL]),
+    set_he_uedges(R, OL_1);
+set_he_uedges([], OL) ->
+    set_he_uedges_2(lists:reverse(OL)).
+set_he_uedges_1(F, [C|[B2|_]=L], OL) ->
+    set_he_uedges_1(F, L, [{C,B2}|OL]);
+set_he_uedges_1(F, [C], OL) ->
+    [{C,F}|OL].
+set_he_uedges_2(Edges) ->
+    set_he_uedges_2(Edges, 0, #{}, []).
+set_he_uedges_2([{A1,A2}|R], Idx, Seen, OL) ->
+    {OL_1, Seen_1} =
+        case maps:is_key({A1,A2},Seen) orelse
+             maps:is_key({A2,A1},Seen)
+        of
+            true ->
+                {OL, Seen};
+            false ->
+                {[{Idx,{A1,A2}}|OL],Seen#{ {A1,A2} => 1 }}
+        end,
+    set_he_uedges_2(R, Idx+1, Seen_1, OL_1);
+set_he_uedges_2([], _Idx, _Seen, OL) ->
+    lists:reverse(OL).
+
+%% ByPolygon smoothing seems to be smoothing groups
+set_he_list_ply(VtxList, SP) ->
+    set_he_list_ply(VtxList, SP, [], orddict:new()).
+set_he_list_ply([F|R], [0|LL], HPly, SGPly) ->
+    %% A value of 0 is assumed to be hard edges all around.
+    set_he_list_ply(R, LL, [set_he_list_ply_edges(F)|HPly], SGPly);
+set_he_list_ply([F|R], [SG|LL], HPly, SGPly)
+  when SG > 0 ->
+    set_he_list_ply(R, LL, HPly,
+        orddict:append_list(SG, set_he_list_ply_edges(F), SGPly));
+set_he_list_ply([], [], HPly, SGPly) ->
+    set_he_list_ply_uedges(
+        lists:append(HPly) ++
+        lists:append([set_he_list_ply_ra(SEL) || {_,SEL} <- SGPly])).
+set_he_list_ply_edges([A|[B|_]=C]) -> set_he_list_ply_edges(A, C, [{A,B}]).
+set_he_list_ply_edges(Pt,[A],OL) -> lists:reverse([{A,Pt}|OL]);
+set_he_list_ply_edges(Pt,[A|[B|_]=C],OL) -> set_he_list_ply_edges(Pt, C, [{A,B}|OL]).
+set_he_list_ply_ra(L) ->
+    AdjE = lists:foldl(fun (A,B) -> gb_sets:insert(A,B) end, gb_sets:empty(), L),
+    set_he_list_ply_ra(L, AdjE, []).
+set_he_list_ply_ra([{A,B}=Tup|L], AdjE, OL) ->
+    case gb_sets:is_member({B,A}, AdjE) of
+        true ->
+            set_he_list_ply_ra(L, AdjE, OL);
+        false ->
+            set_he_list_ply_ra(L, AdjE, [Tup|OL])
+    end;
+set_he_list_ply_ra([], _, OL) ->
+    lists:reverse(OL).
+set_he_list_ply_uedges(L) ->
+    set_he_list_ply_uedges(L, gb_sets:empty()).
+set_he_list_ply_uedges([{A,B}=Tup|L], UE) ->
+    case gb_sets:is_member({B,A},UE) of
+        true ->
+            set_he_list_ply_uedges(L, UE);
+        false ->
+            set_he_list_ply_uedges(L, gb_sets:insert(Tup, UE))
+    end;
+set_he_list_ply_uedges([], UE) ->
+    gb_sets:to_list(UE).
+
+
+
+from_fbx_material_prop([], _, {number, I0}) ->
+    I0;
+from_fbx_material_prop([Name|RL], Prop, {number, _}=Default) ->
+    case proplists:get_value(Name, Prop, none) of
+        {Atm, I} when is_atom(Atm),is_number(I) -> float(I);
+        none -> from_fbx_material_prop(RL, Prop, Default)
+    end;
+from_fbx_material_prop([], _, {color, R0,G0,B0}) ->
+    {R0,G0,B0};
+from_fbx_material_prop([Name|RL], Prop, {color, _,_,_}=Default) ->
+    case proplists:get_value(Name, Prop, none) of
+        {Atm,R,G,B}
+          when is_atom(Atm),is_number(R),is_number(G),is_number(B) ->
+            {float(R),float(G),float(B)};
+        {Atm,R,G,B,_}
+          when is_atom(Atm),is_number(R),is_number(G),is_number(B) ->
+            {float(R),float(G),float(B)};
+        none -> from_fbx_material_prop(RL, Prop, Default)
+    end.
+
+from_fbx_material({mat,MatName,Cont}, FBXPath)
+  when is_atom(MatName) -> %% 'Material_default'
+    Maps = from_fbx_tex(Cont,FBXPath),
+    
+    Prop = proplists:get_value(prop, Cont, []),
+    EmCol = from_fbx_material_prop([<<"Emissive">>,<<"EmissiveColor">>], Prop, {color,0.0,0.0,0.0}),
+    EmIntens = from_fbx_material_prop([<<"EmissiveFactor">>], Prop, {number,0.0}),
+    AmCol = from_fbx_material_prop([<<"Ambient">>,<<"AmbientColor">>], Prop, {color,0.0,0.0,0.0}),
+    DifCol = from_fbx_material_prop([<<"Diffuse">>,<<"DiffuseColor">>], Prop, {color,0.5,0.5,0.5}),
+    DifIntens = from_fbx_material_prop([<<"DiffuseFactor">>], Prop, {number,0.8}),
+    SpecCol = from_fbx_material_prop([<<"Specular">>,<<"SpecularColor">>], Prop, {color,1.0,1.0,1.0}),
+    SpecIntens = from_fbx_material_prop([<<"SpecularFactor">>], Prop, {number,0.25}),
+    Shine = from_fbx_material_prop([<<"Shininess">>], Prop, {number,9.0}),
+    RefleIntens = from_fbx_material_prop([<<"ReflectionFactor">>], Prop, {number,0.1}),
+
+    OpenGL = {opengl, [
+        {ambient, rgb_to_rgba(AmCol)},
+        {specular, rgb_to_rgba(SpecCol, SpecIntens)},
+        {shininess, float(Shine)},
+        {diffuse, rgb_to_rgba(DifCol, DifIntens)},
+        {emission, rgb_to_rgba(EmCol, EmIntens)},
+        {metallic, RefleIntens},
+        {roughness,0.8},
+        {vertex_colors, set}
+    ]},
+    {MatName, [OpenGL] ++ if length(Maps) > 0 -> [{maps, Maps}]; true -> [] end }.
+
+rgb_to_rgba({R,G,B}) ->
+    rgb_to_rgba({R,G,B}, 1.0).
+rgb_to_rgba({R,G,B}, Alpha) ->
+    {float(R),float(G),float(B),float(Alpha)}.
+
+
+from_fbx_tex(L, FBXPath) ->
+    from_fbx_tex(L, FBXPath, []).
+from_fbx_tex([{{tex, {for, Which, TexName}}, Cont}|L], FBXPath, OL) ->
+    {_UseMipMap, FileName, RelFileName} = from_fbx_tex_img(Cont),
+    MapAtom = case Which of
+        <<"DiffuseColor">> -> diffuse;
+        <<"NormalMap">> -> normal;
+        <<"Bump">> -> bump;
+        <<"ReflectionFactor">> -> metallic;
+        <<"ShininessExponent">> -> roughness;
+        <<"EmissiveColor">> -> emission;
+        _ ->
+            io:format("~p: Unknown Texture Type: ~p~n", [?MODULE, Which]),
+            unknown
+    end,
+    case proplists:get_value(type, Cont, []) of
+        <<"TextureVideoClip">> ->
+            FileNameTex = proplists:get_value(filename, Cont, none),
+            RelFileNameTex = proplists:get_value(relfilename, Cont, none),
+            case load_image(find_image_file(FBXPath, [RelFileName, RelFileNameTex, FileNameTex, FileName])) of
+                E3DIm=#e3d_image{} ->
+                    from_fbx_tex(L, FBXPath, [{MapAtom, E3DIm#e3d_image{name=TexName}}|OL]);
+                {error, Err} ->
+                    io:format("~p: NOTE: Texture not loaded: ~p~n", [?MODULE,Err]),
+                    from_fbx_tex(L, FBXPath, OL)
+            end
+    end;
+from_fbx_tex([_|L], FBXPath, OL) ->
+    from_fbx_tex(L, FBXPath, OL);
+from_fbx_tex([], _, OL) ->
+    lists:reverse(OL).
+
+load_image({error, Err}) ->
+    {error, Err};
+load_image(Filename)
+  when is_list(Filename) ->
+    get_bitmap_by_ext(Filename).
+
+get_bitmap_by_ext(FilePath) ->
+    Ext = case string:to_lower(filename:extension(FilePath)) of
+        ".jpeg" -> ".jpg";
+        Ext_0   -> Ext_0
+    end,
+    F = case Ext of
+        ".png" ->
+            fun read_png/1;
+        ".jpg" ->
+            fun read_jpeg/1;
+        _ ->
+            fun read_default/1
+    end,
+    F(FilePath).
+
+read_jpeg(FileName) ->
+    BlockWxMsgs = wxLogNull:new(),
+    Ret = read_jpeg_1(FileName),
+    wxLogNull:destroy(BlockWxMsgs),
+    Ret.
+read_jpeg_1(FileName) ->
+    Image = wxImage:new(),
+    case wxImage:loadFile(Image, FileName) of
+        true ->
+            E3d = wings_image:wxImage_to_e3d(Image),
+            wxImage:destroy(Image),
+            e3d_image:fix_outtype(FileName, E3d, []);
+        false ->
+            {error, {unsupported_by_wxImage, FileName}}
+    end.
+read_png(FileName) ->
+    case e3d__png:load(FileName) of
+        E3D=#e3d_image{} ->
+            E3D;
+        {error, Err} ->
+            {error, Err}
+    end.
+read_default(FileName) ->
+    case e3d_image:load(FileName) of
+        E3DImage=#e3d_image{} ->
+            E3DImage;
+        {error, Err} ->
+            {error, Err}
+    end.
+
+
+
+find_image_file(FBXPath, [none|R]) ->
+    find_image_file(FBXPath, R);
+find_image_file(FBXPath, L0) ->
+    L = [utf8b_to_list(A) || A <- L0, is_binary(A)],
+    [FullPath|_] = L,
+    Filename = filename:basename(FullPath),
+    find_image_file(FBXPath, Filename, L).
+find_image_file(FBXPath, Filename, [FilePath|R]) ->
+    APath = filename:absname(FilePath, FBXPath),
+    case file:read_file_info(APath) of
+        {ok, _} ->
+            APath;
+        _ ->
+            find_image_file(FBXPath, Filename, R)
+    end;
+find_image_file(FBXPath, Filename, []) ->
+    APath = filename:absname(Filename, FBXPath),
+    case file:read_file_info(APath) of
+        {ok, _} ->
+            APath;
+        _ ->
+            {error, {not_found, Filename}}
+    end.
+
+from_fbx_tex_img([{{video, _VidName}, Cont} |_]) ->
+    case proplists:get_value(type, Cont, []) of
+        <<"Clip">> ->
+            UseMipMap = proplists:get_value(usemipmap, Cont, 0),
+            FileName = proplists:get_value(filename, Cont, none),
+            RelFileName = proplists:get_value(relfilename, Cont, none),
+            {UseMipMap, FileName, RelFileName}
+    end;
+from_fbx_tex_img([_|L]) ->
+    from_fbx_tex_img(L).
+
+
+
+%%% The source for the importer is roughly organized as:
+%%%
+%%% * Wings3D plugin interface code near the beginning of the source
+%%% * Turn obj and mat list to #e3d_*{}
+%%% * Build obj and mat list from #fbt{}
+%%% * Traversal of initial FBX structure into #fbt{}
+%%% * Binary reading of the file to initial FBX structure
+%%% * ASCII reading of the file to initial FBX structure
+%%%
+%%% 
+
+%%
+%% Read FBX File
+%%
+
+read_fbx_to_models(Fln) ->
+    {Models,MatL} = rd_fbx(Fln),
+    {Models,MatL}.
+
+
+
+%%% The tuple of objects and materials should look similar
+%%% to these tuple trees.
+%%% 
+%%% {Objs, Mats}
+%%% 
+%%% Objs=
+%%%  [{{model,'Model_Cube'},
+%%%    [{{mat,'Material_default'},mat},
+%%%     {geom,[...,
+%%%            {vertices,[{1.0,1.0,-1.0},
+%%%                       {1.0,-1.0,-1.0},
+%%%                       ...
+%%%                       ]},
+%%%            {vtxindex,[[0,1,2,3],
+%%%                       [4,7,6,5],
+%%%                       ...]},
+%%%            {edges,[0,1,2,3,4,5,6,7,8,10,14,18]},
+%%%            {layerelementnormal,[...,
+%%%                                 {mappinginfotype,<<"ByPolygonVertex">>},
+%%%                                 {refinfotype,<<"Direct">>},
+%%%                                 {normals,[{0.0,0.0,-1.0},
+%%%                                           ...]}]},
+%%%            {layerelementmaterial,[...,
+%%%                                   {mappinginfotype,<<"AllSame">>},
+%%%                                   {refinfotype,<<"IndexToDirect">>},
+%%%                                   {materials,[0]}]}]},
+%%%     {prop,[{<<"Lcl Rotation">>, {lclrotation,0.0,0.0,0.0}},
+%%%            {<<"Lcl Scaling">>,  {lclscaling,100.0,100.0,100.0}},
+%%%            ...]},
+%%%     ...]}]
+%%%
+%%% Mats=
+%%%  [{mat,'Material_default',
+%%%        [...,
+%%%         {shadingmodel,<<"Phong">>},
+%%%         {prop,[{<<"EmissiveColor">>,  {color,0.8,0.8,0.9}},
+%%%                {<<"EmissiveFactor">>, {number,0.0}},
+%%%                {<<"AmbientColor">>,   {color,0.0,0.0,0.0}},
+%%%                {<<"DiffuseColor">>,   {color,0.8,0.8,0.8}},
+%%%                {<<"DiffuseFactor">>,  {number,0.8}},
+%%%                {<<"TransparentColor">>,{color,1.0,1.0,1.0}},
+%%%                {<<"SpecularColor">>,  {color,1.0,1.0,1.0}},
+%%%                {<<"SpecularFactor">>, {number,0.25}},
+%%%                {<<"Shininess">>,      {number,9.0}},
+%%%                {<<"ShininessExponent">>,{number,9.0}},
+%%%                {<<"ReflectionColor">>,  {color,1.0,1.0,1.0}},
+%%%                {<<"ReflectionFactor">>, {number,0.0}}]}]}]
+%%% 
+
+
+%%% Traverse nested models from the root node
+%%%
+
+tmod({_,_,RootList}, MatL) ->
+    {[],Models} = tmod_1(RootList),
+    {Models, MatL}.
+tmod_1(List) ->
+    tmod_1(List, [], []).
+tmod_1([{{model,ID},M}|L], OL, O2) ->
+    {M_1,L_1} = tmod_1(M),
+    A = { {model,ID},
+          move_to_geom(M_1) },
+    tmod_1(L, L_1 ++ [A|OL], O2);
+tmod_1([{{model,ID,MName,MType},M}|L], OL, O2) ->
+    {M_1,L_1} = tmod_1(M),
+    A = { {model,ID,MName,MType},
+          move_to_geom(M_1) },
+    tmod_1(L, L_1 ++ [A|OL], O2);
+tmod_1([A|L], OL, O2) ->
+    tmod_1(L, OL, [A|O2]);
+tmod_1([], OL, O2) ->
+    {lists:reverse(O2), lists:reverse(OL)}.
+
+
+%% Move some tuples to a geom tuple if they are found in 
+%% the model tuple list.
+%%
+move_to_geom(L) ->
+    move_to_geom(L,[],[]).
+move_to_geom([{Atm,_}=V|R], O1, O2)
+  when Atm =:= vertices; Atm =:= vtxindex; Atm =:= geomver;
+       Atm =:= layerelementnormal;
+       Atm =:= layerelementcolor; Atm =:= layerelementsmoothing;
+       Atm =:= layerelementuv; Atm =:= layerelementmaterial ->
+    move_to_geom(R, O1, [V|O2]);
+move_to_geom([E|R], O1, O2) ->
+    move_to_geom(R, [E|O1], O2);
+move_to_geom([], O1, []) ->
+    lists:reverse(O1);
+move_to_geom([], O1, O2)
+  when length(O2) > 0 ->
+    lists:reverse([{geom, lists:reverse(O2)}|O1]).
+
+
+%%% Connect objects to materials and geometry for importing
+%%%
+
+-record(fbt, {
+    header,
+    global,
+    documents,
+    references,
+    objects,
+    connections
+}).
+
+
+%% Use the connection information to merge the different
+%% FBX entities (model, mesh, etc.) into a nested tree.
+%% Geometry will merge into models, materials will get
+%% a reference merged into models, and so on.
+%%
+connectobj(#fbt{objects=ObjL,connections=CL}) ->
+    RootNode = do_connect_obj(sort_connects(CL), to_id_map(ObjL)),
+    RootNode.
+
+split_name_pair(R) ->
+    split_name_pair(R, []).
+split_name_pair(<<0,_,R/binary>>, OL) ->
+    {iolist_to_binary(lists:reverse(OL)), R};
+split_name_pair(<<C,R/binary>>, OL) when C =/= 0, C =/= 1 ->
+    split_name_pair(R, [C|OL]);
+split_name_pair(<<>>, OL) ->
+    {iolist_to_binary(lists:reverse(OL)), <<>>}.
+
+get_atom_from_pair(<<>>) ->
+    NewName = io_lib:format("o~w", [abs(erlang:unique_integer())]),
+    list_to_atom(lists:flatten(NewName));
+get_atom_from_pair(NamePair) when is_binary(NamePair) ->
+    case split_name_pair(NamePair) of
+        {Name, <<>>} ->
+            list_to_atom(utf8b_to_list(Name));
+        {Name, Kind} ->
+            list_to_atom(utf8b_to_list(Kind) ++ "_" ++ utf8b_to_list(Name))
+    end.
+
+utf8b_to_list(A) when is_binary(A) ->
+    unicode:characters_to_list(A, utf8).
+
+%% Turn the list of objects into a map data type where the
+%% key is either the numeric ID or the binary name pair.
+%%
+to_id_map(ObjL) ->
+    to_id_map(ObjL, []).
+to_id_map([{_,{ID,NamePair,_},_}=O|ObjL], OL)
+  when is_number(ID) ->
+    Atom = get_atom_from_pair(NamePair),
+    to_id_map(ObjL, [
+        {ID,{Atom,O}}
+        |OL]);
+to_id_map([{_,{none,NamePair,_},_}=O|ObjL], OL)
+  when is_binary(NamePair) ->
+    Atom = get_atom_from_pair(NamePair),
+    to_id_map(ObjL, [
+        {NamePair,{Atom,O}}
+        |OL]);
+to_id_map([], OL) ->
+    OL_1 = [
+        {0,{none,{rootnode,{0,false,false},[]}}}
+        |OL],
+    maps:from_list(OL_1).
+
+%% When ID numbers are used.
+do_connect_obj([{c,From,To,ConnectType}|CL],IDMap)
+  when is_number(From),
+       is_number(To) ->
+    case maps:is_key(From, IDMap) andalso
+         maps:is_key(To, IDMap)
+    of
+        true ->
+            do_connect_obj_1(From,To,ConnectType,CL,IDMap);
+        false ->
+            do_connect_obj(CL,IDMap)
+    end;
+
+%% When ID numbers are not used.
+do_connect_obj([{c,From,To_0,ConnectType}|CL],IDMap)
+  when is_binary(From),
+       is_binary(To_0) ->
+    To = if To_0 =:= <<"Scene",0,1,"Model">> -> 0;
+            To_0 =:= <<"Model::Scene">> -> 0;
+            true -> To_0 end,
+    case maps:is_key(From, IDMap) andalso
+         maps:is_key(To, IDMap)
+    of
+        true ->
+            do_connect_obj_1(From,To,ConnectType,CL,IDMap);
+        false ->
+            do_connect_obj(CL,IDMap)
+    end;
+
+do_connect_obj([],IDMap) ->
+    case maps:is_key(0, IDMap) of
+        true ->
+            ML = c_materials_list(IDMap),
+            {_, RootNode} = maps:get(0, IDMap),
+            {RootNode, ML};
+        false ->
+            error("Could not find root node")
+    end.
+
+do_connect_obj_1(From,To,ConnectType,CL,IDMap) ->
+    case maps:get(From, IDMap) of
+        {MAtomName, {mat,{_MergeID,_MergeName,_MergeType},_}} ->
+            {AtomName, {Kind,Idents,Obj_0}} = maps:get(To, IDMap),
+            %% Just refer to the material
+            Obj_1 = [{{mat,MAtomName},mat}|Obj_0],
+            IDMap_1 = maps:update(To, {AtomName, {Kind,Idents,Obj_1}}, IDMap),
+            do_connect_obj(CL,IDMap_1);
+        {MAtomName, {MergeKind,{_MergeID,_MergeName,_MergeType},MergeO}} ->
+            {AtomName, {Kind,Idents,Obj_0}} = maps:get(To, IDMap),
+            Obj_1 = case {MergeKind,Kind} of
+                {geom,model} ->
+                    %% We can probably assume there's one geometry
+                    %% for a model
+                    [{MergeKind,MergeO}|Obj_0];
+                _ ->
+                    MAtomName_1 = case ConnectType of
+                        oo ->
+                            MAtomName;
+                        {op, PType} ->
+                            {for, PType, MAtomName}
+                    end,
+                    [{{MergeKind,MAtomName_1},MergeO}|Obj_0]
+            end,
+            IDMap_1 = maps:update(To, {AtomName, {Kind,Idents,Obj_1}}, IDMap),
+            do_connect_obj(CL,IDMap_1)
+    end.
+
+
+%% Make a list of all the materials so they can
+%% be refered to from the models.
+%%
+c_materials_list(IDMap) ->
+    c_materials_list(maps:to_list(IDMap),[]).
+c_materials_list([{_,{MName,{mat,_,Mat}}}|L],ML) ->
+    c_materials_list(L,[{mat,MName,Mat}|ML]);
+c_materials_list([_|L],ML) ->
+    c_materials_list(L,ML);
+c_materials_list([],ML) ->
+    lists:reverse(ML).
+
+
+
+%% Sort the connections so "from" nodes
+%% are fully merged before they are merged
+%% to the next node.
+%%
+sort_connects(L) ->
+    sort_connects(L,[]).
+sort_connects([{c,A,_,_}=Cn|L],OL) ->
+    case nodes_before(A,L) of
+        {[],L_1} ->
+            sort_connects(L_1,[Cn|OL]);
+        {BefL,L_1} ->
+            sort_connects(BefL ++ [Cn|L_1],OL)
+    end;
+sort_connects([],OL) ->
+    lists:reverse(OL).
+nodes_before(For,L) ->
+    nodes_before(For,L,[],[]).
+nodes_before(For,[{c,_,B,_}=Cn|L],BefL,O2)
+  when For =:= B ->
+    nodes_before(For,L,[Cn|BefL],O2);
+nodes_before(For,[Cn|L],BefL,O2) ->
+    nodes_before(For,L,BefL,[Cn|O2]);
+nodes_before(_For,[],BefL,O2) ->
+    {lists:reverse(BefL),lists:reverse(O2)}.
+
+    
+
+
+
+
+
+%%% FBX import traversal after parsing
+%%%
+
+%% The following functions take patterns of FBX elements
+%% and turn them into a particular data type for a parent
+%% element.
+%%
+
+%% Take a list of numbers for an element.
+%%
+trav_numlist(Atm,List,Etc,OL) ->
+    trav_numlist(Atm,List,Etc,OL, fun(A) -> A end).
+trav_numlist(Atm,[[]],_,OL,_AfterFun) ->
+    [{Atm,[]}|OL];
+trav_numlist(Atm,[[Num|_]=Numbers],_,OL,AfterFun)
+  when is_float(Num); is_integer(Num) ->
+    [{Atm,AfterFun(Numbers)}|OL];
+trav_numlist(Atm,[{double,Num}|_]=L1,_,OL,AfterFun)
+  when is_float(Num); is_integer(Num) ->
+    Numbers = [float(N) || {double,N} <- L1],
+    [{Atm,AfterFun(Numbers)}|OL];
+trav_numlist(Atm,[{int,Num}|_]=L1,_,OL,AfterFun)
+  when is_float(Num); is_integer(Num) ->
+    Numbers = [N || {int,N} <- L1],
+    [{Atm,AfterFun(Numbers)}|OL];
+trav_numlist(Atm,[{starnum,_Count}|_],[{<<"a">>,L1,_}|_]=_List,OL,AfterFun) ->
+    Numbers = [N || {number,N} <- L1],
+    [{Atm,AfterFun(Numbers)}|OL];
+trav_numlist(Atm,[{number,Num}|_]=L1,_,OL,AfterFun)
+  when is_float(Num) ->
+    Numbers = [float(N) || {number,N} <- L1],
+    [{Atm,AfterFun(Numbers)}|OL];
+trav_numlist(Atm,[{number,_}|_]=L1,_,OL,AfterFun) ->
+    Numbers = [N || {number,N} <- L1],
+    [{Atm,AfterFun(Numbers)}|OL].
+
+
+%% Take a boolean for an element
+%%
+trav_bool(Atm,[{bool,Num}|_],_,OL) ->
+    [{Atm,Num}|OL];
+trav_bool(Atm,[{T,Num}|_],_,OL)
+  when T =:= int orelse
+       (T =:= number andalso is_integer(Num)) ->
+    [{Atm, Num > 0 }|OL].
+
+
+%% Take an integer for an element.
+%%
+trav_int(Atm,[{int,Num}|_],_,OL) ->
+    [{Atm,Num}|OL];
+trav_int(Atm,[{number,Num}|_],_,OL) when is_integer(Num) ->
+    [{Atm,Num}|OL].
+
+
+%% Take a string for an element
+%%
+trav_str(Atm,[Str|_],_,OL) when is_binary(Str) ->
+    [{Atm,Str}|OL].
+
+
+%% Take a pair of numbers for an element
+%%
+trav_num2(Atm,[{int,Num1},{int,Num2}|_],_,OL) ->
+    [{Atm,{Num1,Num2}}|OL];
+trav_num2(Atm,[{FT1,Num1},{FT2,Num2}|_],_,OL)
+  when FT1 =:= float orelse FT1 =:= double,
+       FT2 =:= float orelse FT2 =:= double ->
+    [{Atm,{float(Num1),float(Num2)}}|OL];
+trav_num2(Atm,[{number,Num1},{number,Num2}|_],_,OL) ->
+    [{Atm,{Num1,Num2}}|OL].
+
+
+%% Take a quad of numbers for an element.
+%%
+trav_num4(Atm,[{int,Num1},{int,Num2},{int,Num3},{int,Num4}|_],_,OL) ->
+    [{Atm,{Num1,Num2,Num3,Num4}}|OL];
+trav_num4(Atm,[{float,Num1},{float,Num2},{float,Num3},{float,Num4}|_],_,OL) ->
+    [{Atm,{Num1,Num2,Num3,Num4}}|OL];
+trav_num4(Atm,[{number,Num1},{number,Num2},{number,Num3},{number,Num4}|_],_,OL) ->
+    [{Atm,{Num1,Num2,Num3,Num4}}|OL].
+
+
+%% The following function is where the FBX is initially
+%% traversed and a #fbt{} record is built.
+%%
+
+%% Traverse the top sections of the FBX structure.
+%%
+trav(S) when is_list(S) ->
+    trav_1(S,#fbt{}).
+trav_1([], FBT) ->
+    FBT;
+trav_1([{Name,_Prop,List}|L], FBT) ->
+    FBT_1 = case Name of
+        <<"FBXHeaderExtension">> -> FBT#fbt{header=trav_header(List)};
+        <<"GlobalSettings">> -> FBT#fbt{global=trav_global(List)};
+        <<"Documents">> -> FBT#fbt{documents=trav_documents(List)};
+        <<"References">> -> FBT#fbt{references=trav_references(List)};
+        <<"Definitions">> -> FBT;
+        <<"Objects">> -> FBT#fbt{objects=trav_objects(List)};
+        <<"Connections">> -> FBT#fbt{connections=trav_connections(List)};
+        _Unknown ->
+            FBT
+    end,
+    trav_1(L, FBT_1).
+
+
+
+trav_header(_L) ->
+    [].
+
+trav_global(_L) ->
+    [].
+
+trav_documents(_L) ->
+    [].
+
+trav_references(_L) ->
+    [].
+
+
+%% Traverse the objects top part of the FBX structure.
+%%
+trav_objects(List) ->
+    trav_objects(List,[]).
+trav_objects([], FT) ->
+    lists:reverse(FT);
+trav_objects([{Name,Prop,List}|L], FT) ->
+    FT_1 = case Name of
+        <<"Geometry">> ->
+            trav_obj_geom(Prop, List, FT);
+        <<"Model">> ->
+            trav_obj_model(Prop, List, FT);
+        <<"Material">> ->
+            trav_obj_material(Prop, List, FT);
+        <<"Video">> ->
+            trav_obj_video(Prop, List, FT);
+        <<"Texture">> ->
+            trav_obj_texture(Prop, List, FT);
+
+        _ ->
+            FT
+    end,
+    trav_objects(L, FT_1).
+
+
+%% Get the different identifiers that are in the parameters
+%% of models, geometry and material nodes.
+%%
+idents_from_prop([{Atm, ID}, NamePair, Type])
+  when is_binary(NamePair),
+       is_binary(Type),
+       (Atm =:= number orelse Atm =:= int) ->
+    {ID, NamePair, Type};
+idents_from_prop([NamePair, Type])
+  when is_binary(NamePair),
+       is_binary(Type) ->
+    {none, NamePair, Type}.
+
+
+
+%% Turn Vertices list to list of tuples
+%%
+numbers_to_tuplelist(List) ->
+    numbers_to_tuplelist(List, []).
+numbers_to_tuplelist([X,Y,Z|L], OL) ->
+    numbers_to_tuplelist(L, [{X,Y,Z}|OL]);
+numbers_to_tuplelist([], OL) ->
+    lists:reverse(OL).
+    
+
+%% Turn UV list to list of tuples
+%%
+numbers_to_tuplelist2(List) ->
+    numbers_to_tuplelist2(List, []).
+numbers_to_tuplelist2([X,Y|L], OL) ->
+    numbers_to_tuplelist2(L, [{X,Y}|OL]);
+numbers_to_tuplelist2([], OL) ->
+    lists:reverse(OL).
+    
+
+%% Turn PolygonVertexIndex list to list of lists.
+%%
+polyvtxi_to_lists(List) ->
+    polyvtxi_to_lists(List, [], []).
+polyvtxi_to_lists([A|L], O1, OL) when A >= 0 ->
+    polyvtxi_to_lists(L, [A|O1], OL);
+polyvtxi_to_lists([A|L], O1, OL) when A < 0 ->
+    B = lists:reverse([((-A)-1)|O1]),
+    polyvtxi_to_lists(L, [], [B|OL]);
+polyvtxi_to_lists([], [], OL) ->
+    lists:reverse(OL).
+
+
+%% Traverse the initial FBX structure for geometry
+%% information.
+%%
+trav_obj_geom(Prop, List, FT) ->
+    List_1 = trav_obj_geom_1(List, []),
+    Idents = idents_from_prop(Prop),
+    [{geom, Idents, List_1}|FT].
+trav_obj_geom_1([], OL) ->
+    lists:reverse(OL);
+trav_obj_geom_1([{Name,Prop,List}|L], OL) ->
+    OL_1 = case Name of
+        <<"Properties70">> -> trav_prop(Prop,List,OL);
+        <<"Properties60">> -> trav_propb(Prop,List,OL);
+        
+        %% These can be either in a geometry or a model object
+        <<"Vertices">> -> trav_numlist(vertices,Prop,List,OL, fun numbers_to_tuplelist/1);
+        <<"PolygonVertexIndex">> -> trav_numlist(vtxindex,Prop,List,OL, fun polyvtxi_to_lists/1);
+        <<"Edges">> -> trav_numlist(edges,Prop,List,OL);
+        <<"GeometryVersion">> -> trav_int(geomver,Prop,List,OL);
+        <<"LayerElementNormal">> -> trav_obj_geom_layerelementnormal(Prop,List,OL);
+        <<"LayerElementBinormal">> -> OL; % unused
+        <<"LayerElementTangent">> -> OL; % unused
+        <<"LayerElementSmoothing">> -> trav_obj_geom_layerelementsmoothing(Prop,List,OL);
+        <<"LayerElementColor">> -> trav_obj_geom_layerelementcolor(Prop,List,OL);
+        <<"LayerElementUV">> -> trav_obj_geom_layerelementuv(Prop,List,OL);
+        <<"LayerElementMaterial">> -> trav_obj_geom_layerelementmaterial(Prop,List,OL);
+        
+        <<"Layer">> -> OL; % unused
+    
+        _ ->
+            OL
+    end,
+    trav_obj_geom_1(L, OL_1).
+    
+
+trav_obj_geom_layerelementnormal(_Prop,List,FT) ->
+    List_1 = trav_obj_geom_layerelementnormal_1(List,[]),
+    [{layerelementnormal,List_1}|FT].
+trav_obj_geom_layerelementnormal_1([],OL) ->
+    lists:reverse(OL);
+trav_obj_geom_layerelementnormal_1([{Name,Prop,List}|L],OL) ->
+    OL_1 = case Name of
+        <<"Version">> -> trav_int(version,Prop,List,OL);
+        <<"Name">> -> trav_str(name,Prop,List,OL);
+        <<"MappingInformationType">> -> trav_str(mappinginfotype,Prop,List,OL);  % <<"ByVertice">>
+        <<"ReferenceInformationType">> -> trav_str(refinfotype,Prop,List,OL);  % <<"Direct">>
+        <<"Normals">> -> trav_numlist(normals,Prop,List,OL,fun numbers_to_tuplelist/1);
+        <<"NormalsIndex">> -> trav_numlist(normalsindex,Prop,List,OL);
+        <<"NormalsW">> -> trav_numlist(normals_w,Prop,List,OL);
+        _ ->
+            OL
+    end,
+    trav_obj_geom_layerelementnormal_1(L,OL_1).
+
+
+trav_obj_geom_layerelementcolor(_Prop,List,FT) ->
+    List_1 = trav_obj_geom_layerelementcolor_1(List,[]),
+    [{layerelementcolor,List_1}|FT].
+trav_obj_geom_layerelementcolor_1([],OL) ->
+    lists:reverse(OL);
+trav_obj_geom_layerelementcolor_1([{Name,Prop,List}|L],OL) ->
+    OL_1 = case Name of
+        <<"Version">> -> trav_int(version,Prop,List,OL);
+        <<"Name">> -> trav_str(name,Prop,List,OL);
+        <<"MappingInformationType">> -> trav_str(mappinginfotype,Prop,List,OL);  % <<"ByVertice">>
+        <<"ReferenceInformationType">> -> trav_str(refinfotype,Prop,List,OL);  % <<"IndexToDirect">>
+
+        <<"Colors">> -> trav_numlist(colors,Prop,List,OL);
+        _ ->
+            OL
+    end,
+    trav_obj_geom_layerelementcolor_1(L,OL_1).
+
+
+trav_obj_geom_layerelementuv(_Prop,List,FT) ->
+    List_1 = trav_obj_geom_layerelementuv_1(List,[]),
+    [{layerelementuv,List_1}|FT].
+trav_obj_geom_layerelementuv_1([],OL) ->
+    lists:reverse(OL);
+trav_obj_geom_layerelementuv_1([{Name,Prop,List}|L],OL) ->
+    OL_1 = case Name of
+        <<"Version">> -> trav_int(version,Prop,List,OL);
+        <<"Name">> -> trav_str(name,Prop,List,OL);
+        <<"MappingInformationType">> -> trav_str(mappinginfotype,Prop,List,OL);  % <<"ByVertice">>
+        <<"ReferenceInformationType">> -> trav_str(refinfotype,Prop,List,OL);  % <<"Direct">>
+
+        <<"UV">> -> trav_numlist(uv,Prop,List,OL, fun numbers_to_tuplelist2/1);
+        <<"UVIndex">> -> trav_numlist(uvindex,Prop,List,OL);
+        
+        _ ->
+            OL
+    end,
+    trav_obj_geom_layerelementuv_1(L,OL_1).
+
+
+trav_obj_geom_layerelementmaterial(_Prop,List,FT) ->
+    List_1 = trav_obj_geom_layerelementmaterial_1(List,[]),
+    [{layerelementmaterial,List_1}|FT].
+trav_obj_geom_layerelementmaterial_1([],OL) ->
+    lists:reverse(OL);
+trav_obj_geom_layerelementmaterial_1([{Name,Prop,List}|L],OL) ->
+    OL_1 = case Name of
+        <<"Version">> -> trav_int(version,Prop,List,OL);
+        <<"Name">> -> trav_str(name,Prop,List,OL);
+        <<"MappingInformationType">> -> trav_str(mappinginfotype,Prop,List,OL);  % <<"AllSame">>
+        <<"ReferenceInformationType">> -> trav_str(refinfotype,Prop,List,OL);  % <<"IndexToDirect">>
+        <<"Materials">> -> trav_numlist(materials,Prop,List,OL);
+        
+        _ ->
+            OL
+    end,
+    trav_obj_geom_layerelementmaterial_1(L,OL_1).
+    
+
+trav_obj_geom_layerelementsmoothing(_Prop,List,FT) ->
+    List_1 = trav_obj_geom_layerelementsmoothing_1(List,[]),
+    [{layerelementsmoothing,List_1}|FT].
+trav_obj_geom_layerelementsmoothing_1([],OL) ->
+    lists:reverse(OL);
+trav_obj_geom_layerelementsmoothing_1([{Name,Prop,List}|L],OL) ->
+    OL_1 = case Name of
+        <<"Version">> -> trav_int(version,Prop,List,OL);
+        <<"Name">> -> trav_str(name,Prop,List,OL);
+        <<"MappingInformationType">> -> trav_str(mappinginfotype,Prop,List,OL);
+        <<"ReferenceInformationType">> -> trav_str(refinfotype,Prop,List,OL);
+        <<"Smoothing">> -> trav_numlist(smoothing,Prop,List,OL);
+        
+        _ ->
+            OL
+    end,
+    trav_obj_geom_layerelementsmoothing_1(L,OL_1).
+
+
+%% Traverse the initial FBX structure for models
+%%
+trav_obj_model(Prop, List, FT) ->
+    List_1 = trav_obj_model_1(List, []),
+    Idents = idents_from_prop(Prop),
+    [{model, Idents, List_1}|FT].
+trav_obj_model_1([], OL) ->
+    lists:reverse(OL);
+trav_obj_model_1([{Name,Prop,List}|L], OL) ->
+    OL_1 = case Name of
+        <<"Properties70">> -> trav_prop(Prop,List,OL);
+        <<"Properties60">> -> trav_propb(Prop,List,OL);
+        <<"Version">> -> trav_int(version,Prop,List,OL);
+        <<"Shading">> -> trav_bool(shading,Prop,List,OL);
+        <<"Culling">> -> trav_str(culling,Prop,List,OL);
+
+        %% These can be either in a geometry or a model object,
+        %% older FBXs seem to have them in models.
+        %%
+        <<"Vertices">> -> trav_numlist(vertices,Prop,List,OL, fun numbers_to_tuplelist/1);
+        <<"PolygonVertexIndex">> -> trav_numlist(vtxindex,Prop,List,OL, fun polyvtxi_to_lists/1);
+        <<"GeometryVersion">> -> trav_int(geomver,Prop,List,OL);
+        <<"LayerElementNormal">> -> trav_obj_geom_layerelementnormal(Prop,List,OL);
+        <<"LayerElementBinormal">> -> OL; %% unused
+        <<"LayerElementTangent">> -> OL; %% unused
+        <<"LayerElementSmoothing">> -> trav_obj_geom_layerelementsmoothing(Prop,List,OL);
+        <<"LayerElementColor">> -> trav_obj_geom_layerelementcolor(Prop,List,OL);
+        <<"LayerElementUV">> -> trav_obj_geom_layerelementuv(Prop,List,OL);
+        <<"LayerElementMaterial">> -> trav_obj_geom_layerelementmaterial(Prop,List,OL);
+        
+        _ ->
+            OL
+    end,
+    trav_obj_model_1(L, OL_1).
+
+
+%% Traverse the initial FBX structure for materials
+%%
+trav_obj_material(Prop, List, FT) ->
+    Idents = idents_from_prop(Prop),
+    List_1 = trav_obj_material_1(List, []),
+    [{mat, Idents, List_1}|FT].
+trav_obj_material_1([], OL) ->
+    lists:reverse(OL);
+trav_obj_material_1([{Name,Prop,List}|L], OL) ->
+    OL_1 = case Name of
+        <<"Properties70">> -> trav_prop(Prop,List,OL);
+        <<"Properties60">> -> trav_propb(Prop,List,OL);
+        <<"Version">> -> trav_int(version,Prop,List,OL);
+        <<"ShadingModel">> -> trav_str(shadingmodel,Prop,List,OL);
+        <<"MultiLayer">> -> trav_int(multilayer,Prop,List,OL);
+
+        _ ->
+            OL
+    end,
+    trav_obj_material_1(L, OL_1).
+
+
+
+
+%% Traverse the initial FBX structure for image references,
+%% they are refered to as videos but also are used for images.
+%%
+trav_obj_video(Prop, List, FT) ->
+    Idents = idents_from_prop(Prop),
+    List_1 = trav_obj_video_1(List, []),
+    [{video, Idents, List_1}|FT].
+trav_obj_video_1([], OL) ->
+    lists:reverse(OL);
+trav_obj_video_1([{Name,Prop,List}|L], OL) ->
+    OL_1 = case Name of
+        <<"Properties70">> -> trav_prop(Prop,List,OL);
+        <<"Properties60">> -> trav_propb(Prop,List,OL);
+        <<"Version">> -> trav_int(version,Prop,List,OL);
+        
+        <<"Type">> -> trav_str(type,Prop,List,OL);
+        <<"UseMipMap">> -> trav_int(usemipmap,Prop,List,OL);
+        <<"Filename">> -> trav_str(filename,Prop,List,OL);
+        <<"RelativeFilename">> -> trav_str(relfilename,Prop,List,OL);
+
+        _ ->
+            OL
+    end,
+    trav_obj_video_1(L, OL_1).
+
+
+%% Traverse the initial FBX structure for textures.
+%%
+trav_obj_texture(Prop, List, FT) ->
+    Idents = idents_from_prop(Prop),
+    List_1 = trav_obj_texture_1(List, []),
+    [{tex, Idents, List_1}|FT].
+trav_obj_texture_1([], OL) ->
+    lists:reverse(OL);
+trav_obj_texture_1([{Name,Prop,List}|L], OL) ->
+    OL_1 = case Name of
+        <<"Properties70">> -> trav_prop(Prop,List,OL);
+        <<"Properties60">> -> trav_propb(Prop,List,OL);
+        <<"Version">> -> trav_int(version,Prop,List,OL);
+        
+        <<"Type">> -> trav_str(type,Prop,List,OL);
+        <<"TextureName">> -> trav_str(texname,Prop,List,OL);
+        <<"Media">> -> trav_str(media,Prop,List,OL);
+        <<"FileName">> -> trav_str(filename,Prop,List,OL);
+        <<"RelativeFilename">> -> trav_str(relfilename,Prop,List,OL);
+        <<"ModelUVTranslation">> -> trav_num2(modeluvtranslation,Prop,List,OL);
+        <<"ModelUVScaling">> -> trav_num2(modeluvscaling,Prop,List,OL);
+        <<"Texture_Alpha_Source">> -> trav_str(alphasrc,Prop,List,OL);
+        <<"Cropping">> -> trav_num4(cropping,Prop,List,OL);
+
+        _ ->
+            OL
+    end,
+    trav_obj_texture_1(L, OL_1).
+
+
+%% Traverse the initial FBX structure for connection
+%% information.
+%%
+trav_connections(L) ->
+    trav_connections_1(L, []).
+trav_connections_1([], OL) ->
+    lists:reverse(OL);
+trav_connections_1([{W,[<<"OO">>,{Tp1,Num1},{Tp2,Num2}],[]}|L], OL)
+  when (W =:= <<"C">> orelse W =:= <<"Connect">>),
+       (Tp1 =:= number orelse Tp1 =:= int),
+       (Tp2 =:= number orelse Tp2 =:= int) ->
+    trav_connections_1(L, [{c,Num1,Num2,oo}|OL]);
+trav_connections_1([{W,[<<"OO">>,Str1,Str2],[]}|L], OL)
+  when (W =:= <<"C">> orelse W =:= <<"Connect">>),
+       is_binary(Str1), is_binary(Str2) ->
+    trav_connections_1(L, [{c,Str1,Str2,oo}|OL]);
+trav_connections_1([{W,[<<"OP">>,{Tp1,Num1},{Tp2,Num2},Kind],[]}|L], OL)
+  when (W =:= <<"C">> orelse W =:= <<"Connect">>),
+       (Tp1 =:= number orelse Tp1 =:= int),
+       (Tp2 =:= number orelse Tp2 =:= int),
+       is_binary(Kind) ->
+    trav_connections_1(L, [{c,Num1,Num2,{op,Kind}}|OL]);
+trav_connections_1([{W,[<<"OP">>,Str1,Str2,Kind],[]}|L], OL)
+  when (W =:= <<"C">> orelse W =:= <<"Connect">>),
+       is_binary(Str1), is_binary(Str2), is_binary(Kind) ->
+    trav_connections_1(L, [{c,Str1,Str2,{op,Kind}}|OL]).
+
+
+-define(PROP(A), A).
+-define(T_FLOAT(A),
+    (Tp =:= double orelse
+     Tp =:= float orelse
+     Tp =:= number)).
+-define(T_INT(A,Num),
+    (Tp =:= int orelse
+     (Tp =:= number andalso is_integer(Num)))).
+     
+
+-define(LISTPROP(Name,Other,L),
+    [{<<"P">>,[Name|Other],_}|L]
+).
+
+
+%% Forms of properties
+%%
+trav_prop(_Prop, List, PL) ->
+    List_1 = trav_prop_1(List, []),
+    [{prop, List_1}|PL].
+trav_prop_1([], OL) ->
+    lists:reverse(OL);
+trav_prop_1(?LISTPROP(Name,[
+                <<"Color">>,<<>>,<<"A">>,
+                {Tp,R},{Tp,G},{Tp,B}
+            ],L), OL)
+  when ?T_FLOAT(Tp) ->
+    trav_prop_1(L, [{Name,{color,float(R),float(G),float(B)}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"ColorRGB">>,<<"Color">>,<<>>,
+                {Tp,R},{Tp,G},{Tp,B}
+            ],L), OL)
+  when ?T_FLOAT(Tp) ->
+    trav_prop_1(L, [{Name,{color_rgb,float(R),float(G),float(B)}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"Number">>,<<>>,<<"A">>,
+                {Tp,Num}
+            ],L), OL)
+  when ?T_FLOAT(Tp) orelse Tp =:= int ->
+    trav_prop_1(L, [{Name,{number,Num}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"Vector3D">>,<<"Vector">>,<<>>,
+                {Tp,X},{Tp,Y},{Tp,Z}
+            ],L), OL)
+  when ?T_FLOAT(Tp) ->
+    trav_prop_1(L, [{Name,{vec3d,float(X),float(Y),float(Z)}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"double">>,<<"Number">>,<<>>,
+                {Tp,Num}
+            ],L), OL)
+  when ?T_FLOAT(Tp) ->
+    trav_prop_1(L, [{Name,{double,float(Num)}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"int">>,<<"Integer">>,<<>>,{Tp,Num}
+            ],L), OL)
+  when ?T_INT(Tp,Num) ->
+    trav_prop_1(L, [{Name,{int,Num}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"bool">>,<<>>,<<>>,{Tp,Num}
+            ],L), OL)
+  when ?T_INT(Tp,Num) ->
+    trav_prop_1(L, [{Name,{bool,Num}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"enum">>,<<>>,<<>>,{Tp,Num}
+            ],L), OL)
+  when ?T_INT(Tp, Num) ->
+    trav_prop_1(L, [{Name,{enum,Num}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"Lcl Translation">>,<<>>,<<"A",_/binary>>,{Tp,X},{Tp,Y},{Tp,Z}
+            ],L), OL)
+  when ?T_FLOAT(Tp) ->
+    trav_prop_1(L, [{Name,{lcltranslation,float(X),float(Y),float(Z)}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"Lcl Scaling">>,<<>>,<<"A",_/binary>>,{Tp,X},{Tp,Y},{Tp,Z}
+            ],L), OL)
+  when ?T_FLOAT(Tp) ->
+    trav_prop_1(L, [{Name,{lclscaling,float(X),float(Y),float(Z)}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"Lcl Rotation">>,<<>>,<<"A",_/binary>>,{Tp,X},{Tp,Y},{Tp,Z}
+            ],L), OL)
+  when ?T_FLOAT(Tp) ->
+    trav_prop_1(L, [{Name,{lclrotation,float(X),float(Y),float(Z)}}|OL]);
+
+trav_prop_1(?LISTPROP(Name,[
+                <<"KString">>,<<>>,<<"U">>,Str
+            ],L), OL)
+  when is_binary(Str) ->
+    trav_prop_1(L, [{Name,{kstring,Str}}|OL]);
+
+trav_prop_1(?LISTPROP(Name,[
+                <<"KString">>,<<>>,<<>>,Str
+            ],L), OL)
+  when is_binary(Str) ->
+    trav_prop_1(L, [{Name,{kstring,Str}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"KString">>,_,<<>>,Str
+            ],L), OL)
+  when is_binary(Str) ->
+    trav_prop_1(L, [{Name,{kstring,Str}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"Bool">>,<<>>,<<"A">>,{Tp,Num}
+            ],L), OL)
+  when ?T_INT(Tp,Num) ->
+    trav_prop_1(L, [{Name,{bool_a,Num}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"Integer">>,<<>>,<<"A">>,{Tp,Num}
+            ],L), OL)
+  when ?T_INT(Tp,Num) ->
+    trav_prop_1(L, [{Name,{integer_a,Num}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"Float">>,<<>>,<<"A">>,
+                {Tp,Num}
+            ],L), OL)
+  when ?T_FLOAT(Tp) ->
+    trav_prop_1(L, [{Name,{float_a,Num}}|OL]);
+trav_prop_1(?LISTPROP(Name,[
+                <<"ColorAndAlpha">>,<<>>,<<"A">>,
+                {Tp,R},{Tp,G},{Tp,B},{Tp,Alph}
+            ],L), OL)
+  when ?T_FLOAT(Tp) ->
+    trav_prop_1(L, [{Name,{color_alpha,float(R),float(G),float(B),float(Alph)}}|OL]);
+
+trav_prop_1(?LISTPROP(Name,[<<"Reference">>,<<>>,<<"A">>],L), OL) ->
+    trav_prop_1(L, [{Name,{reference}}|OL]);
+trav_prop_1(?LISTPROP(Name,[<<"Compound">>,<<>>,<<>>],L), OL) ->
+    trav_prop_1(L, [{Name,{compound}}|OL]);
+
+trav_prop_1([{_Name,_,_}|L], OL) ->
+    %% Unknown property kind
+    trav_prop_1(L, OL).
+
+
+
+%% Older forms of properties (Properties60)
+%%
+
+trav_propb(_Prop, List, PL) ->
+    List_1 = trav_propb_1(List, []),
+    [{prop, List_1}|PL].
+trav_propb_1([], OL) ->
+    lists:reverse(OL);
+trav_propb_1([{<<"Property">>,[Name,<<"ColorRGB">>,<<>>,{Tp,R},{Tp,G},{Tp,B}],_}|L], OL)
+  when ?T_FLOAT(Tp) ->
+    trav_propb_1(L, [{Name,{color_rgb,float(R),float(G),float(B)}}|OL]);
+trav_propb_1([{<<"Property">>,[Name,<<"Color">>,<<"A+">>,{Tp,R},{Tp,G},{Tp,B}],_}|L], OL)
+  when ?T_FLOAT(Tp) ->
+    trav_propb_1(L, [{Name,{color,float(R),float(G),float(B)}}|OL]);
+trav_propb_1([{<<"Property">>,[Name,<<"Vector3D">>,<<>>,{Tp,X},{Tp,Y},{Tp,Z}],_}|L], OL)
+  when ?T_FLOAT(Tp) ->
+    trav_propb_1(L, [{Name,{vec3d,float(X),float(Y),float(Z)}}|OL]);
+trav_propb_1([{<<"Property">>,[Name,<<"Number">>,<<"A+">>,{Tp,Num}],_}|L], OL)
+  when ?T_FLOAT(Tp) ->
+    trav_propb_1(L, [{Name,{double,float(Num)}}|OL]);
+trav_propb_1([{<<"Property">>,[Name,<<"double">>,<<>>,{Tp,Num}],_}|L], OL)
+  when ?T_FLOAT(Tp) ->
+    trav_propb_1(L, [{Name,{double,float(Num)}}|OL]);
+trav_propb_1([{<<"Property">>,[Name,<<"bool">>,<<>>,{Tp,Num}],_}|L], OL)
+  when ?T_INT(Tp,Num) ->
+    trav_propb_1(L, [{Name,{bool,Num}}|OL]);
+trav_propb_1([{<<"Property">>,[Name,<<"Lcl Translation">>,<<"A+">>,{Tp,X},{Tp,Y},{Tp,Z}],_}|L], OL)
+  when ?T_FLOAT(Tp) ->
+    trav_propb_1(L, [{Name,{lcltranslation,float(X),float(Y),float(Z)}}|OL]);
+trav_propb_1([{<<"Property">>,[Name,<<"Lcl Scaling">>,<<"A+">>,{Tp,X},{Tp,Y},{Tp,Z}],_}|L], OL)
+  when ?T_FLOAT(Tp) ->
+    trav_propb_1(L, [{Name,{lclscaling,float(X),float(Y),float(Z)}}|OL]);
+trav_propb_1([{<<"Property">>,[Name,<<"Lcl Rotation">>,<<"A+">>,{Tp,X},{Tp,Y},{Tp,Z}],_}|L], OL)
+  when ?T_FLOAT(Tp) ->
+    trav_propb_1(L, [{Name,{lclrotation,float(X),float(Y),float(Z)}}|OL]);
+trav_propb_1([{<<"Property">>,[Name,<<"enum">>,<<>>,{Tp,Num}],_}|L], OL)
+  when ?T_INT(Tp, Num) ->
+    trav_propb_1(L, [{Name,{enum,Num}}|OL]);
+trav_propb_1([{<<"Property">>,[Name,<<"charptr">>,_,Str],_}|L], OL)
+  when is_binary(Str) ->
+    trav_propb_1(L, [{Name,{kstring,Str}}|OL]);
+trav_propb_1([{_Name,_,_}|L], OL) ->
+    trav_propb_1(L, OL).
+
+
+%%% Read binary FBX
+%%%
+
+-define(UINT, little-unsigned-integer).
+-define(SINT, little-signed-integer).
+-define(FLT, little-float).
+
+%% Binary with position to track offsets
+-record(binp, {
+    c :: binary(),
+    p :: integer()
+}).
+
+%% With a filename, read the file contents and either read
+%% it as a binary file or call read_fbxa_content/1 if it
+%% is an ASCII file.
+%%
+rd_fbx(Filename) ->
+    case file:read_file(Filename) of
+        {ok, BinCont} ->
+            Cont = #binp{c=BinCont,p=0},
+            case read_header(Cont) of
+                {bin32, Cont_1} ->
+                    rd_fbx_1(bin32, Cont_1, []);
+                {bin64, Cont_1} ->
+                    rd_fbx_1(bin64, Cont_1, []);
+                {txt, #binp{c=AscCont}=_} ->
+                    %% Read as ASCII
+                    read_fbxa_content(AscCont)
+            end
+    end.
+rd_fbx_1(BW, Cont, OL) ->
+    case read_record(BW, Cont) of
+        {eorecords, Cont_1} ->
+            rd_fbx_2(Cont_1, lists:reverse(OL));
+        {Rec, Cont_1} ->
+            rd_fbx_1(BW, Cont_1, [Rec|OL])
+    end.
+rd_fbx_2(_Cont, OL) ->
+    {RootNode, ML} = connectobj(trav(OL)),
+    tmod(RootNode, ML).
+
+
+%% Read the header to determine if it is a binary or text file
+%%
+read_header(#binp{c= <<"Kaydara FBX Binary  ",0,16#1A,0,Ver:32/?UINT, R/binary>>,p=Pos}) ->
+    io:format("~p: File ver: ~p~n", [?MODULE, Ver]),
+    if
+        Ver < 7500 ->
+            {bin32, #binp{c=R,p=Pos+27}};
+        true ->
+            {bin64, #binp{c=R,p=Pos+27}}
+    end;
+read_header(#binp{c= <<"Kaydara FBX", _/binary>>=Bin}) ->
+    %% This couldn't be parsed as text if this is encountered
+    %% and wasn't matched as a binary header, so this file might
+    %% not be a recognizable FBX file, return an error.
+    %%
+    io:format("~p: Unknown header: ~s~w~n", [
+        ?MODULE,
+        binary:part(Bin, {0, 20}),
+        binary:part(Bin, {20, 7})]),
+    {error, unknown};
+read_header(BP) ->
+    {txt, BP}.
+
+
+inflate(Bin) ->
+    Z = zlib:open(),
+    ok = zlib:inflateInit(Z, 15),
+    Bin_1 = zlib:inflate(Z, Bin),
+    ok = zlib:inflateEnd(Z),
+    zlib:close(Z),
+    iolist_to_binary(Bin_1).
+
+
+rd_float_list(BP, Len, Enc, _Cln)
+  when Enc =:= 0 ->
+    rd_float_list_1(BP, Len);
+rd_float_list(BP, Len, Enc, Cln)
+  when Enc =:= 1 ->
+    {Comp, BP_1} = rd_bytes(BP, Cln),
+    Decomp = inflate(Comp),
+    {FloatList, _} = rd_float_list_1(#binp{c=Decomp,p=0}, Len),
+    {FloatList, BP_1}.
+rd_float_list_1(BP, Len) ->
+    rd_float_list_1(BP, Len, []).
+rd_float_list_1(BP, 0, OL) ->
+    {lists:reverse(OL), BP};
+rd_float_list_1(#binp{c= <<Data:32/?FLT, R/binary>>,p=Pos}, Len, OL)
+  when Len > 0 ->
+    rd_float_list_1(#binp{c=R,p=Pos+4}, Len-1, [Data|OL]).
+
+
+rd_double_list(BP, Len, Enc, _Cln)
+  when Enc =:= 0 ->
+    rd_double_list_1(BP, Len);
+rd_double_list(BP, Len, Enc, Cln)
+  when Enc =:= 1 ->
+    {Comp, BP_1} = rd_bytes(BP, Cln),
+    Decomp = inflate(Comp),
+    {DoubleList, _} = rd_double_list_1(#binp{c=Decomp,p=0}, Len),
+    {DoubleList, BP_1}.
+rd_double_list_1(BP, Len) ->
+    rd_double_list_1(BP, Len, []).
+rd_double_list_1(BP, 0, OL) ->
+    {lists:reverse(OL), BP};
+rd_double_list_1(#binp{c= <<Data:64/?FLT, R/binary>>,p=Pos}, Len, OL)
+  when Len > 0 ->
+    rd_double_list_1(#binp{c=R,p=Pos+8}, Len-1, [Data|OL]).
+
+rd_longlong_list(BP, Len, Enc, _Cln)
+  when Enc =:= 0 ->
+    rd_longlong_list_1(BP, Len);
+rd_longlong_list(BP, Len, Enc, Cln)
+  when Enc =:= 1 ->
+    {Comp, BP_1} = rd_bytes(BP, Cln),
+    Decomp = inflate(Comp),
+    {LongLongList, _} = rd_longlong_list_1(#binp{c=Decomp,p=0}, Len),
+    {LongLongList, BP_1}.
+rd_longlong_list_1(BP, Len) ->
+    rd_longlong_list_1(BP, Len, []).
+rd_longlong_list_1(BP, 0, OL) ->
+    {lists:reverse(OL), BP};
+rd_longlong_list_1(#binp{c= <<Data1:64/?SINT, R/binary>>,p=Pos}, Len, OL)
+  when Len > 0 ->
+    rd_longlong_list_1(#binp{c=R,p=Pos+8}, Len-1, [Data1|OL]).
+
+
+rd_int_list(BP, Len, Enc, Cln)
+  when Enc =:= 0 ->
+    if Len =:= Cln ->
+        rd_int_list_1_b(BP, Len);
+    true ->
+        rd_int_list_1(BP, Len)
+    end;
+rd_int_list(BP, Len, Enc, Cln)
+  when Enc =:= 1 ->
+    {Comp, BP_1} = rd_bytes(BP, Cln),
+    Decomp = inflate(Comp),
+    {IntList, _} =
+        if  byte_size(Decomp) =:= Len -> % Per byte
+                rd_int_list_1_b(#binp{c=Decomp,p=0}, Len);
+            true ->
+                rd_int_list_1(#binp{c=Decomp,p=0}, Len)
+        end,
+    {IntList, BP_1}.
+rd_int_list_1(BP, Len) ->
+    rd_int_list_1(BP, Len, []).
+rd_int_list_1(BP, 0, OL) ->
+    {lists:reverse(OL), BP};
+rd_int_list_1(#binp{c= <<Data:32/?SINT, R/binary>>,p=Pos}, Len, OL)
+  when Len > 0 ->
+    rd_int_list_1(#binp{c=R,p=Pos+4}, Len-1, [Data|OL]).
+
+rd_int_list_1_b(BP, Len) ->
+    rd_int_list_1_b(BP, Len, []).
+rd_int_list_1_b(BP, 0, OL) ->
+    {lists:reverse(OL), BP};
+rd_int_list_1_b(#binp{c= <<Data:8/?SINT, R/binary>>,p=Pos}, Len, OL)
+  when Len > 0 ->
+    rd_int_list_1_b(#binp{c=R,p=Pos+1}, Len-1, [Data|OL]).
+
+
+
+rd_bytes(#binp{c=R,p=Pos}, Len) ->
+    { binary:part(R, {0, Len}),
+      #binp{c=binary:part(R, {Len, byte_size(R) - Len}),p=Pos+Len}}.
+
+
+rd_bytes_enc(BP, Cln, 0) ->
+    rd_bytes(BP, Cln);
+rd_bytes_enc(BP, Cln, 1) ->
+    {Comp, BP_1} = rd_bytes(BP, Cln),
+    Decomp = inflate(Comp),
+    {Decomp, BP_1}.
+
+
+read_record_prop(#binp{c= <<Type, R/binary>>,p=Pos_0}) ->
+    Pos = Pos_0+1,
+    case Type of
+        $v ->
+            <<Prim_s:16/?SINT, R_1/binary>> = R,
+            { {short, Prim_s},
+              #binp{c=R_1,p=Pos+2} };
+        $C ->
+            <<Prim_b/?SINT, R_1/binary>> = R,
+            { {int, Prim_b},
+              #binp{c=R_1,p=Pos+1} };
+        $I ->
+            <<Prim_i:32/?SINT, R_1/binary>> = R,
+            { {int, Prim_i},
+              #binp{c=R_1,p=Pos+4} };
+        $F ->
+            <<Prim_f:32/?FLT, R_1/binary>> = R,
+            { {float, Prim_f},
+              #binp{c=R_1,p=Pos+4} };
+        $D ->
+            <<Prim_d:64/?FLT, R_1/binary>> = R,
+            { {double, Prim_d},
+              #binp{c=R_1,p=Pos+8} };
+        $L ->
+            <<Prim_i:64/?SINT, R_1/binary>> = R,
+            { {int, Prim_i},
+              #binp{c=R_1,p=Pos+8} };
+        
+        $f ->
+            <<Len:32/?UINT, Enc:32/?UINT, Cln:32/?UINT, R_1/binary>> = R,
+            {FloatList, BP_2} = rd_float_list(#binp{c=R_1,p=Pos+12}, Len, Enc, Cln),
+            {FloatList, BP_2};
+        $d ->
+            <<Len:32/?UINT, Enc:32/?UINT, Cln:32/?UINT, R_1/binary>> = R,
+            {DoubleList, BP_2} = rd_double_list(#binp{c=R_1,p=Pos+12}, Len, Enc, Cln),
+            {DoubleList, BP_2};
+        $l ->
+            <<Len:32/?UINT, Enc:32/?UINT, Cln:32/?UINT, R_1/binary>> = R,
+            {LongLongList, BP_2} = rd_longlong_list(#binp{c=R_1,p=Pos+12}, Len, Enc, Cln),
+            {LongLongList, BP_2};
+        $i ->
+            <<Len:32/?UINT, Enc:32/?UINT, Cln:32/?UINT, R_1/binary>> = R,
+            {IntList, BP_2} = rd_int_list(#binp{c=R_1,p=Pos+12}, Len, Enc, Cln),
+            {IntList, BP_2};
+        $b ->
+            <<Len:32/?UINT, Enc:32/?UINT, Cln:32/?UINT, R_1/binary>> = R, %% Bool
+            {BoolList, BP_2} = rd_int_list(#binp{c=R_1,p=Pos+12}, Len, Enc, Cln),
+            {BoolList, BP_2};
+    
+        $S ->
+            <<Len:32/?UINT, R_1/binary>> = R,
+            {String, BP_2} = rd_bytes(#binp{c=R_1,p=Pos+4}, Len),
+            {String, BP_2};
+        $R ->
+            <<Len:32/?UINT, R_1/binary>> = R,
+            {Data, BP_2} = rd_bytes(#binp{c=R_1,p=Pos+4}, Len),
+            {Data, BP_2};
+
+        $c ->
+            <<_Len:32/?UINT,Enc:32/?UINT,Cln:32/?UINT, R_1/binary>> = R,
+            {String, BP_2} = rd_bytes_enc(#binp{c=R_1,p=Pos+12}, Cln, Enc),
+            {String, BP_2};
+
+        _ ->
+            io:format(
+                "~p: Unknown: '~c' num=~w at byte position ~w R=~w\n",
+                [?MODULE, Type, Type, Pos, binary:part(R, {0, 50})]),
+            error(1)
+    end.
+
+
+%% 32-bit offsets for version < 7500
+%%
+read_record(bin32, #binp{c= <<EndOffset:32/?UINT,NumP:32/?UINT,PropLen:32/?UINT,NameLen,R/binary>>,p=Pos})
+  when EndOffset > Pos; EndOffset =:= 0 ->
+    read_record_1(bin32, #binp{c=R,p=Pos+4+4+4+1}, EndOffset,NumP,PropLen,NameLen);
+
+%% 64-bit offsets for version >= 7500
+%%
+read_record(bin64,#binp{c= <<EndOffset:64/?UINT,NumP:64/?UINT,PropLen:64/?UINT,NameLen,R/binary>>,p=Pos})
+  when EndOffset > Pos; EndOffset =:= 0 ->
+    read_record_1(bin64, #binp{c=R,p=Pos+8+8+8+1}, EndOffset,NumP,PropLen,NameLen).
+
+read_record_1(_, BP, EndOffset,_NumP,_PropLen,_NameLen)
+  when EndOffset =:= 0 ->
+    %% This is a null padding, return and exit loop
+    {eorecords, BP};
+read_record_1(BW, BP, EndOffset,NumP,PropLen,NameLen)
+  when NameLen > 0 ->
+    {Name, BP_1} = rd_bytes(BP, NameLen),
+    read_record_2(BW, BP_1, EndOffset,NumP,PropLen,Name);
+read_record_1(BW, BP, EndOffset,NumP,PropLen,NameLen)
+  when NameLen =:= 0 ->
+    read_record_2(BW, BP, EndOffset,NumP,PropLen,<<>>).
+
+read_record_2(BW, BP, EndOffset,NumP,PropLen,Name) ->
+    read_record_2(BW, BP, EndOffset,NumP,PropLen,Name,[]).
+read_record_2(BW, BP, EndOffset,NumP,PropLen,Name,Props)
+  when NumP > 0 ->
+    {P, BP_1} = read_record_prop(BP),
+    read_record_2(BW, BP_1, EndOffset,NumP-1,PropLen,Name,[P|Props]);
+read_record_2(BW, BP, EndOffset,0,PropLen,Name,Props) ->
+    read_record_3(BW, BP, EndOffset,lists:reverse(Props),PropLen,Name).
+
+read_record_3(BW, #binp{p=Pos}=BP, EndOffset,Props,_PropLen,Name)
+  when Pos < EndOffset ->
+    {Records, BP_1} = read_record_3_r(BW, BP, []),
+    {{Name, Props, Records}, BP_1};
+read_record_3(_, #binp{p=Pos}=BP, EndOffset,Props,_PropLen,Name)
+  when Pos =:= EndOffset ->
+    {{Name, Props, []}, BP}.
+
+read_record_3_r(BW, BP, OL) ->
+    case read_record(BW, BP) of
+        {eorecords, BP_1} ->
+            {lists:reverse(OL), BP_1};
+        {Rec, BP_1} ->
+            read_record_3_r(BW, BP_1, [Rec|OL])
+    end.
+
+
+
+%%% Read ASCII FBX
+%%%
+
+%% Read the binary contents as an ASCII representation of
+%% the FBX file.
+%%
+read_fbxa_content(Cont) ->
+    {ok, Tokens} = tok(fbxa_strip_comments(Cont)),
+    {ok, P} = parse(Tokens),
+    {RootNode, ML} = connectobj(trav(P)),
+    tmod(RootNode, ML).
+
+%% Remove comments from FBX text
+fbxa_strip_comments(Content) ->
+    fbxa_strip_comments(Content, []).
+fbxa_strip_comments(<<>>, AL) -> iolist_to_binary(lists:reverse(AL));
+fbxa_strip_comments(Content, AL) ->
+    case binary:split(Content, <<34>>) of
+        [BeforeString, InString] -> 
+            case fbxa_strip_comments_outside_string(BeforeString) of
+                {no_comment, BeforeString_1} ->
+                    {InString_2, Rest_2} = fbxa_strip_comments_inside_string(InString),
+                    fbxa_strip_comments(Rest_2, [<<34>>,InString_2,<<34>>,BeforeString_1|AL]);
+                {had_comment, BeforeString_1} ->
+                    %% If the previous part of the source has a comment
+                    %% then the double quote inside the comment doesn't carry to the next line.
+                    case binary:split(InString, <<10>>) of
+                        [_] -> error;
+                        [_CommentedString, NextLine] ->
+                            fbxa_strip_comments(NextLine, [BeforeString_1|AL])
+                    end
+            end;
+        [_NoString] ->
+            {_, Rest_1} = fbxa_strip_comments_outside_string(Content),
+            iolist_to_binary(lists:reverse([Rest_1 | AL]))
+    end.
+fbxa_strip_comments_inside_string(Content) ->
+    fbxa_strip_comments_inside_string(Content, []).
+
+fbxa_strip_comments_inside_string(<<>>, AL) ->
+    {iolist_to_binary(lists:reverse(AL)), <<>>};
+fbxa_strip_comments_inside_string(<<DQ:8, Rest/binary>>, AL) when DQ =:= 34 ->
+    {iolist_to_binary(lists:reverse(AL)), Rest};
+fbxa_strip_comments_inside_string(<<Char:8, Rest/binary>>, AL) ->
+    fbxa_strip_comments_inside_string(Rest, [Char|AL]).
+
+fbxa_strip_comments_outside_string(Content) ->
+    fbxa_strip_comments_outside_string(Content, []).
+fbxa_strip_comments_outside_string(Content, AL) ->
+    case binary:split(Content, <<10>>) of
+        [ThisLine, R] ->
+            case binary:split(ThisLine, <<";">>) of
+                [Keep, _] -> fbxa_strip_comments_outside_string(R, [Keep | AL]);
+                [Keep]    -> fbxa_strip_comments_outside_string(R, [Keep | AL])
+            end;
+        [LastLine] ->
+            %% Only the last line matters whether a comment character appears
+            %% which overrides the string afterwards.
+            case binary:split(LastLine, <<";">>) of
+                [Keep, _] -> {had_comment, iolist_to_binary(lists:reverse([Keep|AL]))};
+                [Keep]    -> {no_comment,  iolist_to_binary(lists:reverse([Keep|AL]))}
+            end
+    end.
+
+
+
+tok(A) ->
+    tok(A, [], []).
+tok(<<>>, [], Toks) ->
+    {ok, lists:reverse(Toks)};
+tok(<<>>, Current, Toks) ->
+    tok(<<>>, [], [tok_w(Current)|Toks]);
+tok(<<WhiteSpace:8, Rest/binary>>, Current, Toks)
+    when WhiteSpace =:= 32;
+         WhiteSpace =:= 10; WhiteSpace =:= 13;
+         WhiteSpace =:= 9 ->
+    case Current of
+        [] -> tok(Rest, Current, Toks);
+        _  -> tok(Rest, [], [tok_w(Current)|Toks])
+    end;
+tok(<<DQ:8, Rest_0/binary>>, Current, Toks)
+    when DQ =:= 34 ->
+    {InsideString, Rest_1} = tok_inside_string(Rest_0),
+    case Current of
+        [] -> tok(Rest_1, Current, [InsideString | Toks]);
+        _  -> tok(Rest_1, [], [InsideString, tok_w(Current)|Toks])
+    end;
+tok(<<SC:8, Rest/binary>>, Current, Toks)
+    when SC =:= ${; SC =:= $};
+         SC =:= $,; SC =:= $:; SC =:= $*  ->
+    case Current of
+        [] -> tok(Rest, Current, [fbxa_tok(SC)|Toks]);
+        _  -> tok(Rest, [], [fbxa_tok(SC),tok_w(Current)|Toks])
+    end;
+tok(<<Char:8, Rest/binary>>, Current, Toks) ->
+    tok(Rest, [Char|Current], Toks).
+
+tok_inside_string(A) -> tok_inside_string(A, []).
+tok_inside_string(<<>>, AL) -> {iolist_to_binary(lists:reverse(AL)), <<>>};
+tok_inside_string(<<DQ:8, Rest/binary>>, AL) when DQ =:= 34 ->
+    {iolist_to_binary(lists:reverse(AL)), Rest};
+tok_inside_string(<<Char:8, Rest/binary>>, AL) ->
+    tok_inside_string(Rest, [Char|AL]).
+
+tok_w(A) ->
+    fbxa_word_or_number(iolist_to_binary(lists:reverse(A))).
+    
+fbxa_word_or_number(<<B:8,_/binary>>=A)
+  when B >= $0, B =< $9; B =:= $.; B =:= $- ->
+    {number, parsenumber(A)};
+fbxa_word_or_number(A) -> {word, A}.
+
+parsenumber(A) ->
+    parsenumber_1(binary_to_list(A)).
+parsenumber_1(Num_S) ->
+    parsenumber_2(Num_S).
+parsenumber_2([$.|R]) -> parsenumber_2([$0,$.|R]);
+parsenumber_2(Num_S) ->
+    case string:split(Num_S, "e") of
+        [LExpNum_S, RExpNum_S] ->
+            LExpNum = case string:to_float(LExpNum_S) of
+                {error, no_float} -> 
+                    case string:to_integer(LExpNum_S) of
+                        {error, _} -> 0;
+                        {Num_1, _} -> Num_1
+                    end;
+                {Num_1, _} -> Num_1
+            end,
+            RExpNum = case string:to_float(RExpNum_S) of
+                {error, no_float} -> 
+                    case string:to_integer(RExpNum_S) of
+                        {error, _} -> 0;
+                        {Num_2, _} -> Num_2
+                    end;
+                {Num_2, _} -> Num_2
+            end,
+            LExpNum * math:pow(10, RExpNum);
+        [_NoExponent] ->
+            case string:to_float(Num_S) of
+                {error, no_float} -> 
+                    case string:to_integer(Num_S) of
+                        {error, _} -> 0;
+                        {Num_1, _} -> Num_1
+                    end;
+                {Num_1, _} -> Num_1
+            end
+    end.
+
+fbxa_tok($,) -> comma;
+fbxa_tok($*) -> star; %% e.g. as *24
+fbxa_tok($:) -> colon;
+fbxa_tok(${) -> open_curly;
+fbxa_tok($}) -> close_curly.
+
+parse(T) ->
+    parse(T, []).
+parse(T, Cont) ->
+    case T of
+        [close_curly|_] -> {ok, lists:reverse(Cont), T};
+        [] -> {ok, lists:reverse(Cont)};
+        [{word, Word}, colon|Rest0] ->
+            {ok, Params, Content, Rest1} = parse_record(Rest0),
+            parse(Rest1, [{Word, Params, Content} | Cont])
+    end.
+
+
+parse_record(T) ->
+    {ok, Params, T_1} = parse_params(T),
+    case T_1 of
+        [open_curly|T_2] ->
+            {ok, List, T_3} = parse(T_2),
+            case T_3 of
+                [close_curly|T_4] ->
+                    {ok, Params, List, T_4}
+            end;
+        _ ->
+            {ok, Params, [], T_1}
+    end.
+
+
+parse_params(T) ->
+    parse_params(T, []).
+parse_params(T, OL) ->
+    case T of
+        [close_curly|_] ->
+            {ok, lists:reverse(OL), T};
+        [open_curly|_] ->
+            {ok, lists:reverse(OL), T};
+        [star,{number,Number},comma|T_2] ->
+            parse_params(T_2, [{starnum, Number}|OL]);
+        [{number,Number},comma,{word,<<"L">>}|T_2] -> %% Used in "Takes"
+            parse_params(T_2, [{number, Number}|OL]);
+        [{number,Number},comma|T_2] ->
+            parse_params(T_2, [{number, Number}|OL]);
+        [Str,comma|T_2] when is_binary(Str) ->
+            parse_params(T_2, [Str|OL]);
+        [{word, BoolS},comma|T_2]
+          when BoolS =:= <<"T">>;
+               BoolS =:= <<"F">>;
+               BoolS =:= <<"Y">>;
+               BoolS =:= <<"N">>;
+               BoolS =:= <<"W">> ->
+            parse_params(T_2, [{bool, fbxa_bool_str(BoolS)}|OL]);
+        [star,{number,Number}|T_2] ->
+            parse_params(T_2, [{starnum, Number}|OL]);
+        [{number,Number}|T_2] ->
+            parse_params(T_2, [{number, Number}|OL]);
+        [Str|T_2] when is_binary(Str) ->
+            parse_params(T_2, [Str|OL]);
+        [{word,BoolS}|T_2]
+          when BoolS =:= <<"T">>;
+               BoolS =:= <<"F">>;
+               BoolS =:= <<"Y">>;
+               BoolS =:= <<"N">>;
+               BoolS =:= <<"W">> ->
+            parse_params(T_2, [{bool, fbxa_bool_str(BoolS)}|OL]);
+        [{word, _}|_] ->
+            {ok, lists:reverse(OL), T}
+    end.
+
+fbxa_bool_str(<<"T">>) ->
+    true;
+fbxa_bool_str(<<"F">>) ->
+    false;
+fbxa_bool_str(<<"Y">>) ->
+    true;
+fbxa_bool_str(<<"N">>) ->
+    false;
+fbxa_bool_str(<<"W">>) ->
+    true.
+
+%%%
+%%%
+
+
+t_bin() ->
+    {ok,Fo}=file:open("debug.out",[write]),
+    {Models,Mats}=read_fbx_to_models("box.fbx"),io:format(Fo,"Models=~p~nMats=~p~n", [Models,Mats]),file:close(Fo).
+
diff --git a/plugins_src/import_export/wpc_fbx_p.erl b/plugins_src/import_export/wpc_fbx_p.erl
new file mode 100644
index 00000000..9b59e16a
--- /dev/null
+++ b/plugins_src/import_export/wpc_fbx_p.erl
@@ -0,0 +1,1754 @@
+%%
+%%  wpc_fbx_p.erl --
+%%
+%%     FBX file import/export implemented entirely in erlang.
+%%
+%%  Copyright (c) 2023 Edward Blake
+%%
+%%  See the file "license.terms" for information on usage and redistribution
+%%  of this file, and for a DISCLAIMER OF ALL WARRANTIES.
+%%
+%%     $Id$
+%%
+
+-module(wpc_fbx_p).
+
+-export([init/0,menu/2,command/2]).
+
+-import(lists, [map/2,foldl/3,keydelete/3,keyreplace/4,sort/1]).
+
+-include_lib("wings/e3d/e3d.hrl").
+-include_lib("wings/e3d/e3d_image.hrl").
+-include_lib("wings/intl_tools/wings_intl.hrl").
+
+init() ->
+    wpa:pref_set_default(?MODULE, swap_y_z, false),
+    true.
+
+menu({file,import}, Menu) ->
+    menu_entry(Menu);
+menu({file,export}, Menu) ->
+    menu_entry(Menu);
+menu({file,export_selected}, Menu) ->
+    menu_entry(Menu);
+menu(_, Menu) -> Menu.
+
+command({file,{import,{fbx_model,Ask}}}, St) ->
+    fbx_p_import:do_import(Ask, St);
+command({file,{export,{fbx_model,Ask}}}, St) ->
+    Exporter = fun(Ps, Fun) -> wpa:export(Ps, Fun, St) end,
+    do_export(Ask, export, Exporter, St);
+command({file,{export_selected,{fbx_model,Ask}}}, St) ->
+    Exporter = fun(Ps, Fun) -> wpa:export_selected(Ps, Fun, St) end,
+    do_export(Ask, export_selected, Exporter, St);
+command(_, _) ->
+    next.
+
+menu_entry(Menu) ->
+    Menu ++ [{?__(1,"FBX (.fbx)..."),fbx_model,[option]}].
+
+props() ->
+    [{ext,".fbx"},{ext_desc,?__(1,"FBX Model File")}].
+
+
+%%%
+%%% Export.
+%%%
+
+%% FBX export options
+-record(fopt, {
+    compress = true
+}).
+
+
+do_export(Ask, Op, _Exporter, _St) when is_atom(Ask) ->
+    Dialog = [
+        ] ++ common_mesh_options(export) ++ [
+            panel,
+            {?__(3, "Compressed"),true,[{key,compressed}]}
+    ],
+    wpa:dialog(Ask, ?__(1,"FBX Export Options"), Dialog,
+           fun(Res) ->
+               {file,{Op,{fbx_model,Res}}}
+           end);
+do_export(Attr, _Op, Exporter, _St) when is_list(Attr) ->
+    
+    SubDivs = proplists:get_value(subdivisions, Attr, 0),
+    Compressed = proplists:get_value(compressed, Attr, true),
+    IncludeUVs = proplists:get_value(include_uvs, Attr, true),
+    
+    Ps = [{include_uvs,IncludeUVs},
+          {include_hard_edges, true},
+      {subdivisions,SubDivs}|props()],
+    Exporter(Ps, export_fun(Attr, v74, Compressed)).
+
+export_transform(E3dFile, KeyVals) ->
+    Mat = wpa:export_matrix(KeyVals),
+    e3d_file:transform(E3dFile, Mat).
+
+set_pref(KeyVals) ->
+    wpa:pref_set(?MODULE, KeyVals).
+
+export_fun(Attr, _Version, Compressed) ->
+    fun(Filename, Contents_0) ->
+        set_pref(Attr),
+        
+        Dir = filename:dirname(Filename),
+        Filetype = proplists:get_value(default_filetype, Attr, ".png"),
+        Contents_1 = wpa:save_images(Contents_0, Dir, Filetype),
+        
+        #e3d_file{objs=ObjsW,mat=EMat}=export_transform(Contents_1, Attr),
+        
+        FbxOpt = #fopt{compress=Compressed},
+        
+        FilenameExt = filename:extension(Filename),
+        _FilenamePrefix = filename:rootname(Filename, FilenameExt),
+        Objs0 = [
+                    object_for_fbx({}, Obj)
+                || Obj <- ObjsW ],
+        Mats0 = [ material_for_fbx(Mt, Dir) || Mt <- EMat],
+        {Objs, IdAMap_0} = add_ident_numbers(Objs0),
+        {Mats, IdAMap} = add_ident_numbers(Mats0, IdAMap_0),
+        write_fbx_file(Filename, FbxOpt, Objs, Mats, IdAMap),
+        ok
+    end.
+
+
+
+common_mesh_options(Type) ->
+    [wpa:dialog_template(?MODULE, Type, [include_normals,include_colors])].
+
+
+%%% The source for the exporter is roughly organized as:
+%%%
+%%% * Plugin interface code near the beginning of the source.
+%%% * Prepare models and materials from e3d to an intermediate 
+%%%   nested list and tuple structure.
+%%% * Some functions that emit certain binary iolists for file structures.
+%%%   (e.g. write_fbx, bytes_of_*)
+%%% * Functions that turn intermediate nested tuple and list structures 
+%%%   into a nested list binary closer to FBX's file structure.
+%%% * Emit different FBX form sections
+%%% * Emit the properties for each element for the main section.
+%%% * Break out elements out of other elements for FBX's structure,
+%%%   and create connection references between the elements.
+%%% * Assemble the different sections into an iolist
+%%% * Write the actual FBX iolist to file
+%%% * add_ident_number which assigns numeric IDs to entities.
+%%%
+
+
+%%
+%% Write FBX File
+%%
+
+%% Prepare models from e3d to an intermediate 
+%% nested list and tuple structure.
+object_for_fbx(_Options, #e3d_object{name=ObjName,obj=#e3d_mesh{}=Msh}=_) ->
+    #e3d_mesh{ns=Norms,vs=Vertices,tx=Texs,fs=Fs,he=HEs} = e3d_mesh:vertex_normals(Msh),
+    MatList_0 = object_for_fbx_matlist(Fs),
+    MatList_1 = lists:usort([{B,A} || {A,B} <- MatList_0]),
+    MatList = [
+        {{mat, MtName}, mat}
+    || {_MNum, MtName} <- MatList_1 ],
+    
+    %% Calculate the unique edges and if they are soft edges.
+    VtxList = [Vs || #e3d_face{vs=Vs} <- Fs],
+    Edges = uedge_list(VtxList, HEs),
+    {model, ObjName, MatList ++ [
+        {geom, [
+            {vertices, Vertices},
+            {vtxindex, VtxList},
+            {ns, lists:append([from_idx_list(Ns, Norms) || #e3d_face{ns=Ns} <- Fs])},
+            {uv, Texs},
+            {uvidx, [Tx || #e3d_face{tx=Tx} <- Fs]},
+            {mats, [orddict:fetch(Mt, MatList_0) || #e3d_face{mat=[Mt|_]} <- Fs]},
+            {edges, Edges}
+        ]}
+    ]}.
+object_for_fbx_matlist(Fs) ->
+    lists:foldl(
+        fun (#e3d_face{mat=[Mt|_]}, OL) ->
+                case orddict:find(Mt, OL) of
+                    error ->
+                        orddict:store(Mt, orddict:size(OL), OL);
+                    _ ->
+                        OL
+                end
+        end, orddict:new(), Fs).
+
+
+%% Prepare materials from e3d to an intermediate 
+%% nested list and tuple structure.
+material_for_fbx({MatName, Attr}, Dir)
+  when is_atom(MatName) ->
+    OA = proplists:get_value(opengl, Attr, none),
+    OM = proplists:get_value(maps, Attr, none),
+    TexL = material_for_fbx_maps(OM, Dir),
+    
+    {AmR,AmG,AmB,_} = proplists:get_value(ambient, OA, {0.8,0.8,0.8,1.0}),
+    {SpR,SpG,SpB,SpA} = proplists:get_value(specular, OA, {0.8,0.8,0.8,1.0}),
+    Shininess = proplists:get_value(shininess, OA, 0.5),
+    {DfR,DfG,DfB,DfA} = proplists:get_value(diffuse, OA, {0.8,0.8,0.8,1.0}),
+    {EmR,EmG,EmB,EmA} = proplists:get_value(emission, OA, {0.0,0.0,0.0,1.0}),
+    Metallic = proplists:get_value(metallic, OA,0.1),
+    _ = proplists:get_value(roughness, OA,0.8),
+    
+    Props = [
+        {<<"Emissive">>,{vec3d,EmR,EmG,EmB}},
+        {<<"EmissiveColor">>,{color,EmR,EmG,EmB}},
+        {<<"EmissiveFactor">>,{number,EmA}},
+        {<<"Ambient">>,{vec3d,AmR,AmG,AmB}},
+        {<<"AmbientColor">>,{color,AmR,AmG,AmB}},
+        {<<"Diffuse">>,{vec3d,DfR,DfG,DfB}},
+        {<<"DiffuseColor">>,{color,DfR,DfG,DfB}},
+        {<<"DiffuseFactor">>,{number,DfA}},
+        {<<"TransparentColor">>,{color,1.0,1.0,1.0}},
+        {<<"Specular">>,{vec3d,SpR,SpG,SpB}},
+        {<<"SpecularColor">>,{color,SpR,SpG,SpB}},
+        {<<"SpecularFactor">>,{number,SpA}},
+        {<<"Shininess">>,{number,Shininess}},
+        {<<"ReflectionColor">>,{color,1.0,1.0,1.0}},
+        {<<"ReflectionFactor">>,{number,Metallic}}
+    ],
+    
+    {mat, MatName, TexL ++ [{prop, Props}]}.
+
+material_for_fbx_maps(OM, Dir) ->
+    material_for_fbx_maps(OM, Dir, []).
+material_for_fbx_maps([{MapType,#e3d_image{name=MapName,filename=FileName_0}=_}|R], Dir, OL) ->
+    WhichStr = case MapType of
+        diffuse -> <<"DiffuseColor">>;
+        normal -> <<"NormalMap">>;
+        bump -> <<"Bump">>;
+        metallic -> <<"ReflectionFactor">>;
+        roughness -> <<"ShininessExponent">>;
+        emission -> <<"EmissiveColor">>;
+        _ -> <<"Unspecified">>
+    end,
+    
+    FileName = relpath(FileName_0, Dir),
+    
+    FileNameOnly = filename:basename(FileName),
+    
+    FileNameB = str_to_utf8b(FileName),
+    FileNameOnlyB = str_to_utf8b(FileNameOnly),
+    
+    Cont = [
+        {{video, MapName},
+            [ {filename_only, FileNameOnlyB},
+              {relative_path, FileNameB},
+              {prop, [{<<"Path">>, {kstring, FileNameB}}]}
+            ]},
+        {filename_only, FileNameOnlyB},
+        {relative_path, FileNameB},
+        {prop,[{<<"UseMaterial">>,{bool,1}}]}],
+    B={{tex,{for, WhichStr, MapName}},Cont},
+    material_for_fbx_maps(R, Dir, [B|OL]);
+material_for_fbx_maps([], _Dir, OL) ->
+    lists:reverse(OL).
+
+relpath(A, B) ->
+    relpath_1(filename:split(A), filename:split(B)).
+relpath_1([A|B1],[A|B2]) ->
+    relpath_1(B1,B2);
+relpath_1(B1,[]) ->
+    filename:join(B1);
+relpath_1(B1,[_|R1]) ->
+    relpath_1([".."|B1],R1).
+
+from_idx_list(Ns, L_0) ->
+    Arr = array:from_list(L_0),
+    [array:get(Idx, Arr) || Idx <- Ns].
+
+-define(FBX_VERSION, 7400).
+
+%% FBX is in little byte order.
+-define(SINT, little-signed-integer).
+-define(UINT, little-unsigned-integer).
+
+%% note:
+%% If while making modifications, a runtime error happens in these functions,
+%% (e.g. bytes_sint64), it is likely a value was placed in the wrong place 
+%% earlier in the process. e.g. a string got placed into an attr_int tuple.
+%%
+
+bytes_sint64(B) ->
+    <<B:64/?SINT>>.
+bytes_sint32(B) ->
+    <<B:32/?SINT>>.
+bytes_sint8(B) ->
+    <<B:8/?SINT>>.
+bytes_uint32(B) ->
+    <<B:32/?UINT>>.
+bytes_uint8(B) ->
+    <<B:8/?UINT>>.
+bytes_float64(B) ->
+    <<B:64/little-float>>.
+
+%% Write whole iolist
+%%
+write_list(Blist, Fo) ->
+    file:write(Fo, Blist).
+
+bt_count(Blist) when is_list(Blist) ->
+    lists:sum([bt_count(B) || B <- Blist]);
+bt_count(Blist) when is_binary(Blist) ->
+    byte_size(Blist).
+
+
+%% Write the header of the FBX file
+%% 
+bytes_of_header() ->
+    %% Kaydara FBX Binary, two spaces and a nul
+    BytesMagic = <<
+        16#4B,16#61,16#79,16#64,16#61,16#72,16#61,16#20,16#46,16#42,
+        16#58,16#20,16#42,16#69,16#6E,16#61,16#72,16#79,16#20,16#20,16#00>>,
+    
+    %% DOS Ctrl+Z byte used after file signature strings.
+    BytesDOSStop = <<16#1A,16#00>>,
+    
+    %% 4 Byte unsigned int specifying the version.
+    BytesVersionNumber = bytes_uint32(?FBX_VERSION),
+    [ BytesMagic, BytesDOSStop, BytesVersionNumber ].
+
+bytes_of_node_name(Name) when is_list(Name) ->
+    [
+        bytes_uint8(string:length(Name)),
+        iolist_to_binary(Name)
+    ];
+bytes_of_node_name(Name) when is_binary(Name) ->
+    [
+        bytes_uint8(byte_size(Name)),
+        Name
+    ].
+
+
+%% Use deflate to compress some bytes
+%%
+deflate(Bin) ->
+    Z = zlib:open(),
+    ok = zlib:deflateInit(Z, best_compression, deflated, 15, 8, default),
+    Bin_1 = zlib:deflate(Z, Bin),
+    Bin_2 = zlib:deflate(Z, [], finish),
+    ok = zlib:deflateEnd(Z),
+    zlib:close(Z),
+    iolist_to_binary([Bin_1|Bin_2]).
+
+
+bytes_of_node_attribute(StrData) when is_binary(StrData) ->
+    [<<"S">>, bytes_uint32(byte_size(StrData)), StrData];
+bytes_of_node_attribute({attr_str,StrData}) when is_binary(StrData) ->
+    [<<"S">>, bytes_uint32(byte_size(StrData)), StrData];
+bytes_of_node_attribute({attr_str,StrData}) when is_list(StrData) ->
+    StrDataB = str_to_utf8b(StrData),
+    [<<"S">>, bytes_uint32(byte_size(StrDataB)), StrDataB];
+bytes_of_node_attribute({attr_data,DatData}) when is_list(DatData) ->
+    [<<"R">>, bytes_uint32(length(DatData)), iolist_to_binary(DatData)];
+bytes_of_node_attribute({attr_data,DatData}) when is_binary(DatData) ->
+    [<<"R">>, bytes_uint32(byte_size(DatData)), DatData];
+bytes_of_node_attribute({attr_dflo,AttrVal}) ->
+    [<<"D">>, bytes_float64(AttrVal)];
+bytes_of_node_attribute({attr_int,AttrVal})
+  when AttrVal <  1 bsl 32 andalso
+       AttrVal > -1 bsl 32 ->
+    [<<"I">>, bytes_sint32(AttrVal)];
+bytes_of_node_attribute({attr_int,AttrVal})
+  when is_integer(AttrVal) ->
+    [<<"L">>, bytes_sint64(AttrVal)];
+bytes_of_node_attribute({attr_int64,AttrVal}) ->
+    [<<"L">>, bytes_sint64(AttrVal)];
+bytes_of_node_attribute({attr_char,AttrVal}) ->
+    [<<"C">>, bytes_sint8(AttrVal)];
+
+%% Non-compressed list of numbers
+bytes_of_node_attribute({attr_dflo_list, L})
+  when is_list(L) ->
+    Len = length(L),
+    Enc = 0,
+    Bin = iolist_to_binary([bytes_float64(A) || A <- L]),
+    Cln = byte_size(Bin),
+    [<<"d">>, <<Len:32/?UINT, Enc:32/?UINT, Cln:32/?UINT>>, Bin];
+bytes_of_node_attribute({attr_int_list, L})
+  when is_list(L) ->
+    Len = length(L),
+    Enc = 0,
+    Bin = iolist_to_binary([bytes_sint32(A) || A <- L]),
+    Cln = byte_size(Bin),
+    [<<"i">>, <<Len:32/?UINT, Enc:32/?UINT, Cln:32/?UINT>>, Bin];
+
+%% Compressed list of numbers
+bytes_of_node_attribute({{deflate, attr_dflo_list}, L})
+  when is_list(L) ->
+    Len = length(L),
+    Enc = 1,
+    Bin = deflate(iolist_to_binary([bytes_float64(A) || A <- L])),
+    Cln = byte_size(Bin),
+    [<<"d">>, <<Len:32/?UINT, Enc:32/?UINT, Cln:32/?UINT>>, Bin];
+bytes_of_node_attribute({{deflate, attr_int_list}, L})
+  when is_list(L) ->
+    Len = length(L),
+    Enc = 1,
+    Bin = deflate(iolist_to_binary([bytes_sint32(A) || A <- L])),
+    Cln = byte_size(Bin),
+    [<<"i">>, <<Len:32/?UINT, Enc:32/?UINT, Cln:32/?UINT>>, Bin];
+
+%% list style node attribute
+%% [nodeType, [properties ...] | nested-nodes]
+bytes_of_node_attribute([AttrTp,StrData])
+  when is_atom(AttrTp) ->
+    bytes_of_node_attribute({AttrTp,StrData}).
+
+
+
+bytes_of_node_attributes(AttrLst) ->
+    lists:append([ bytes_of_node_attribute(C) || C <- AttrLst]).
+
+bytes_of_node_children(Lst, StartOffset_0) ->
+    case Lst of
+        [] ->
+            []; %% No bytes if no children
+        _ ->
+            {FL,_} =
+                lists:foldl(
+                    fun (C, {NodeBinList, StartOffset}) ->
+                        Bytes = bytes_of_node(C, StartOffset),
+                        {[Bytes | NodeBinList], StartOffset + bt_count(Bytes)}
+                    end, {[], StartOffset_0}, Lst ++ case Lst of [false] -> []; _ -> [false] end
+                ),
+            lists:reverse(FL)
+    end.
+
+bytes_of_node(Node, StartOffset)
+  when is_tuple(Node);
+       Node =:= false ->
+    case Node of
+        false ->
+            EndOffset_0 = 0;
+        _ ->
+            EndOffset_0 = StartOffset + 4 + 4 + 4 + 1
+    end,
+    case Node of
+        
+        {NodeName,NodeAttr,NodeList} when is_list(NodeList) ->
+            NumProperties = length(NodeAttr),
+            PropListBin = bytes_of_node_attributes(NodeAttr),
+            PropertyListLen = bt_count(PropListBin),
+            NodeNameBin = bytes_of_node_name(NodeName),
+            EndOffset_1 = EndOffset_0 + (bt_count(NodeNameBin) - 1) + bt_count(PropListBin),
+            ReturnedNodeListBin = bytes_of_node_children(NodeList, EndOffset_1),
+            NodeListBin = ReturnedNodeListBin,
+            EndOffset_2 = EndOffset_1 + bt_count(NodeListBin);
+        false ->
+            EndOffset_2 = 0,
+            NumProperties = 0,
+            PropertyListLen = 0,
+            PropListBin = [],
+            NodeListBin = [],
+            NodeNameBin = [0],
+            EndOffset_2 = EndOffset_0
+    end,
+    [
+        bytes_uint32(EndOffset_2),
+        bytes_uint32(NumProperties),
+        bytes_uint32(PropertyListLen),
+        case Node of
+            false ->
+                [ <<0>> ];
+            _ ->
+                [
+                NodeNameBin,
+                PropListBin,
+                NodeListBin
+                ]
+        end
+    ];
+bytes_of_node([NodeName,NodeAttr|NodeList], StartOffset) ->
+    bytes_of_node({NodeName,NodeAttr,NodeList}, StartOffset).
+
+bytes_of_uuid(UUID) ->
+    case length(UUID) =:= 16 of
+        true ->
+            iolist_to_binary(UUID);
+        false ->
+            iolist_to_binary(string:copies([0], 16)) %% 16 bytes
+    end.
+
+bytes_of_padding_120_zeros() ->
+    %% 120 bytes of padded zeros
+    iolist_to_binary(string:copies([0], 120)).
+
+
+
+bytes_of_00_00() ->
+    <<16#00,16#00>>.
+
+bytes_of_version() ->
+    BytesVersionNumber = bytes_uint32(?FBX_VERSION),
+    BytesVersionNumber.
+
+bytes_of_alignment_padding(Offset) ->
+    %% Pad with zeros for 16 byte alignment
+    MLen = Offset rem 16,
+    case MLen > 0 of
+        true ->
+            iolist_to_binary(string:copies([0], 16 - MLen));
+        false ->
+            []
+    end.
+
+
+%% Write the header, the main body and the footer of the FBX
+%%
+write_fbx({MainBody,UUIDIsh_1,UUIDIsh_2}) ->
+    StartOffset_0 = 0,
+    
+    BytesHeader = bytes_of_header(),
+    StartOffset_1 = bt_count(BytesHeader) + StartOffset_0,
+    BytesMainBody = bytes_of_node_children(MainBody, StartOffset_1),
+    
+    BytesUUID1 = bytes_of_uuid(UUIDIsh_1),
+    StartOffset_2 = bt_count(BytesMainBody) + bt_count(BytesUUID1) + StartOffset_1,
+    
+    %% At least in some files, there tends to be a UUID-like block, followed
+    %% by what seems to be some padding zeros to align at a 16-byte boundary,
+    %% it can be noticed the first UUID-like block isn't aligned, but everything
+    %% after is aligned. After the alignment padding, bytes of the file version
+    %% appears (like in the header), and some more zeros and then another
+    %% UUID-like block, but some files across different versions are sometimes 
+    %% different from this.
+    %%
+    BytesPad1 = bytes_of_alignment_padding(StartOffset_2),
+    BytesPad2 = bytes_of_00_00(),
+    BytesPad3 = bytes_of_00_00(),
+    BytesPad4 = bytes_of_version(),
+    BytesPad5 = bytes_of_padding_120_zeros(),
+    BytesUUID2 = bytes_of_uuid(UUIDIsh_2),
+    
+    [
+        BytesHeader,
+        BytesMainBody,
+        BytesUUID1,
+        BytesPad1,
+        BytesPad2,
+        BytesPad3,
+        BytesPad4,
+        BytesPad5,
+        BytesUUID2
+    ].
+
+%%%
+%%%
+%%%
+
+%%% Functions that turn intermediate nested tuple and list structures 
+%%% into a nested list binary closer to FBX's file structure.
+
+
+-define(FBX_OBJECTS_MODEL_VERSION, 232).
+-define(FBX_SUMMARY_VERSION, 101).
+-define(FBX_SUMMARY_TAKES_VERSION, 101).
+-define(FBX_DEFINITIONS_VERSION, 100).
+-define(FBX_OBJECTS_MODEL_LAYERELEMENT_VERSION, 101).
+-define(FBX_OBJECTS_MODEL_LAYER_VERSION, 100).
+-define(FBX_OBJECTS_MATERIAL_VERSION, 101).
+-define(FBX_AMBIENTRENDERSETTINGS_VERSION, 101).
+-define(FBX_GEOMETRY_VERSION, 124).
+
+name_type_pair(Name, Type)
+  when is_list(Name),
+       is_binary(Type) ->
+    name_type_pair(str_to_utf8b(Name), Type);
+name_type_pair(Name, Type)
+  when is_binary(Name),
+       is_binary(Type) ->
+    <<Name/binary, 0, 1, Type/binary>>.
+
+
+
+%% Property tuples to FBX data types
+%%
+
+-define(PROPTUPLE(Name, Cont), 
+    {<<"P">>,[iolist_to_binary(Name) | Cont],[]}
+    ).
+
+prop({Name,{color,R,G,B}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Color">>,<<>>,<<"A">>,
+            {attr_dflo,R},
+            {attr_dflo,G},
+            {attr_dflo,B}
+    ]);
+prop({Name,{color_rgb,R,G,B}}) ->
+    ?PROPTUPLE(Name, [
+        <<"ColorRGB">>, <<"Color">>, <<>>,
+            {attr_dflo,R},
+            {attr_dflo,G},
+            {attr_dflo,B}
+    ]);
+prop({Name,{number,Num}}) when is_integer(Num) ->
+    ?PROPTUPLE(Name, [
+        <<"Number">>,<<>>,<<"A">>,
+            {attr_int,Num}
+    ]);
+prop({Name,{number,Num}}) when is_float(Num) ->
+    ?PROPTUPLE(Name, [
+        <<"Number">>,<<>>,<<"A">>,
+            {attr_dflo,Num}
+    ]);
+prop({Name,{vec3d,X,Y,Z}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Vector3D">>,<<"Vector">>,<<>>,
+            {attr_dflo,X},
+            {attr_dflo,Y},
+            {attr_dflo,Z}
+    ]);
+prop({Name,{double,Num}}) ->
+    ?PROPTUPLE(Name, [
+        <<"double">>,<<"Number">>,<<>>,
+            {attr_dflo,Num}
+    ]);
+prop({Name,{int,Num}}) ->
+    ?PROPTUPLE(Name, [
+        <<"int">>,<<"Integer">>,<<>>,
+            {attr_int,Num}
+    ]);
+prop({Name,{bool,Num}}) ->
+    ?PROPTUPLE(Name, [
+        <<"bool">>,<<>>,<<>>,
+            {attr_int,Num}
+    ]);
+prop({Name,{enum,Num}}) ->
+    ?PROPTUPLE(Name, [
+        <<"enum">>,<<>>,<<>>,
+            {attr_int,Num}
+    ]);
+prop({Name,{lcltranslation,X,Y,Z}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Lcl Translation">>,<<>>,<<"A">>,
+            {attr_dflo,X},
+            {attr_dflo,Y},
+            {attr_dflo,Z}
+    ]);
+prop({Name,{lclscaling,X,Y,Z}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Lcl Scaling">>,<<>>,<<"A">>,
+            {attr_dflo,X},
+            {attr_dflo,Y},
+            {attr_dflo,Z}
+    ]);
+prop({Name,{lclrotation,X,Y,Z}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Lcl Rotation">>,<<>>,<<"A">>,
+            {attr_dflo,X},
+            {attr_dflo,Y},
+            {attr_dflo,Z}
+    ]);
+prop({Name,{ktime,Time}}) ->
+    ?PROPTUPLE(Name, [
+        <<"KTime">>,<<>>,<<>>,
+            {attr_int64, Time}
+    ]);
+prop({Name,{kstring,Str}}) when is_binary(Str) ->
+    ?PROPTUPLE(Name, [
+        <<"KString">>,<<>>,<<>>,Str
+    ]);
+prop({Name,{kstring_xrefurl,Str}}) when is_binary(Str) ->
+    ?PROPTUPLE(Name, [
+        <<"KString">>,<<"XRefUrl">>,<<>>,Str
+    ]);
+prop({Name,{datetime,Str}}) when is_binary(Str) ->
+    ?PROPTUPLE(Name, [
+        <<"DateTime">>,<<>>,<<>>,Str
+    ]);
+prop({Name,{visibility,Val}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Visibility">>, <<>>, <<"A">>,
+            {attr_dflo, Val}
+    ]);
+prop({Name,{object}}) ->
+    ?PROPTUPLE(Name, [
+        <<"object">>, <<>>, <<>>
+    ]);
+prop({Name,{reference}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Reference">>,<<>>,<<"A">>
+    ]);
+prop({Name,{compound}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Compound">>,<<>>,<<>>
+    ]);
+prop({Name,{bool_a,Num}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Bool">>,<<>>,<<"A">>,
+            {attr_int,Num}
+    ]);
+prop({Name,{integer_a,Num}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Integer">>,<<>>,<<"A">>,
+            {attr_int,Num}
+    ]);
+prop({Name,{float_a,Num}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Float">>,<<>>,<<"A">>,
+            {attr_dflo,Num}
+    ]);
+prop({Name,{color_alpha,R,G,B,Alph}}) ->
+    ?PROPTUPLE(Name, [
+        <<"ColorAndAlpha">>,<<>>,<<"A">>,
+            {attr_dflo,R},
+            {attr_dflo,G},
+            {attr_dflo,B},
+            {attr_dflo,Alph}
+    ]);
+prop({Name,{visibility_inheritance,B}}) ->
+    ?PROPTUPLE(Name, [
+        <<"Visibility Inheritance">>,<<>>,<<>>,
+            {attr_int,B}
+    ]);
+
+prop({Name,{vectex,X,Y,Z}}) ->  % Shows up in texture properties.
+    ?PROPTUPLE(Name, [
+        <<"Vector">>, <<>>, <<"A">>,
+            {attr_dflo, X},
+            {attr_dflo, Y},
+            {attr_dflo, Z}
+    ]).
+
+
+%% Turn list of tuple properties into list of FBX nested parameters.
+%%
+proplist_to_properties70(PropLst) ->
+    [<<"Properties70">>, [] |
+        lists:map(fun prop/1, PropLst)].
+
+
+%% Default properties for materials that will show up in the
+%% template part of definitions.
+%%
+default_properties70_material() ->
+    [
+        {<<"ShadingModel">>, {kstring, <<"Phong">>}},
+        {<<"MultiLayer">>, {bool, 0}},
+        {<<"EmissiveColor">>, {color, 0.0, 0.0, 0.0}},
+        {<<"EmissiveFactor">>,{number,1.0}},
+        {<<"AmbientColor">>, {color, 0.0, 0.0, 0.0}},
+        {<<"AmbientFactor">>, {number, 1.0}},
+        {<<"DiffuseColor">>, {color, 0.0, 0.0, 0.0}},
+        {<<"DiffuseFactor">>,{number,1.0}},
+        {<<"NormalMap">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"Bump">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"BumpFactor">>, {double, 1.0}},
+        {<<"TransparentColor">>,{color,1.0,1.0,1.0}},
+        {<<"TransparencyFactor">>, {number, 0.0}},
+        {<<"Opacity">>, {number, 1.0}},
+        {<<"DisplacementColor">>, {color_rgb, 0.0, 0.0, 0.0}},
+        {<<"DisplacementFactor">>, {double, 1.0}},
+        {<<"VectorDisplacementColor">>, {color_rgb, 0.0, 0.0, 0.0}},
+        {<<"VectorDisplacementFactor">>, {double, 1.0}},
+        {<<"SpecularColor">>, {color, 0.0, 0.0, 0.0}},
+        {<<"SpecularFactor">>,{number,1.0}},
+        {<<"Opacity">>, {number, 1.0}},
+        {<<"ReflectionColor">>,{color,0.0,0.0,0.0}},
+        {<<"ReflectionFactor">>, {number, 1.0}},
+        {<<"Shininess">>, {number, 0.0}},
+        {<<"ShininessExponent">>,{number,20.0}}
+    ].
+
+
+%% Default properties for geometries that will show up
+%% in the template part of the definitions.
+%%
+default_properties70_geometry() ->
+    [
+        {<<"Color">>, {color_rgb, 0.9, 0.9, 0.9}},
+        {<<"BBoxMin">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"BBoxMax">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"Primary Visibility">>, {bool, 1}},
+        {<<"Casts Shadows">>, {bool, 1}},
+        {<<"Receive Shadows">>, {bool, 1}}
+    ].
+    
+
+%% Default properties for models that will show up
+%% in the template part of the definitions.
+%%
+default_properties70_object() ->
+    [
+        {<<"QuaternionInterpolate">>, {enum, 0}},
+        {<<"RotationOffset">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"RotationPivot">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"ScalingOffset">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"ScalingPivot">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"TranslationActive">>, {bool, 0}},
+        {<<"TranslationMin">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"TranslationMax">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"TranslationMinX">>, {bool, 0}},
+        {<<"TranslationMinY">>, {bool, 0}},
+        {<<"TranslationMinZ">>, {bool, 0}},
+        {<<"TranslationMaxX">>, {bool, 0}},
+        {<<"TranslationMaxY">>, {bool, 0}},
+        {<<"TranslationMaxZ">>, {bool, 0}},
+        {<<"RotationOrder">>, {enum, 0}},
+        {<<"RotationSpaceForLimitOnly">>, {bool, 0}},
+        {<<"RotationStiffnessX">>, {double, 0.0}},
+        {<<"RotationStiffnessY">>, {double, 0.0}},
+        {<<"RotationStiffnessZ">>, {double, 0.0}},
+        {<<"AxisLen">>, {double, 10.0}},
+        {<<"PreRotation">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"PostRotation">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"RotationActive">>, {bool, 0}},
+        {<<"RotationMin">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"RotationMax">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"RotationMinX">>, {bool, 0}},
+        {<<"RotationMinY">>, {bool, 0}},
+        {<<"RotationMinZ">>, {bool, 0}},
+        {<<"RotationMaxX">>, {bool, 0}},
+        {<<"RotationMaxY">>, {bool, 0}},
+        {<<"RotationMaxZ">>, {bool, 0}},
+        {<<"InheritType">>, {enum, 0}},
+        {<<"ScalingActive">>, {bool, 0}},
+        {<<"ScalingMin">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"ScalingMax">>, {vec3d, 1.0, 1.0, 1.0}},
+        {<<"ScalingMinX">>, {bool, 0}},
+        {<<"ScalingMinY">>, {bool, 0}},
+        {<<"ScalingMinZ">>, {bool, 0}},
+        {<<"ScalingMaxX">>, {bool, 0}},
+        {<<"ScalingMaxY">>, {bool, 0}},
+        {<<"ScalingMaxZ">>, {bool, 0}},
+        {<<"GeometricTranslation">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"GeometricRotation">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"GeometricScaling">>, {vec3d, 1.0, 1.0, 1.0}},
+        {<<"MinDampRangeX">>, {double, 0.0}},
+        {<<"MinDampRangeY">>, {double, 0.0}},
+        {<<"MinDampRangeZ">>, {double, 0.0}},
+        {<<"MaxDampRangeX">>, {double, 0.0}},
+        {<<"MaxDampRangeY">>, {double, 0.0}},
+        {<<"MaxDampRangeZ">>, {double, 0.0}},
+        {<<"MinDampStrengthX">>, {double, 0.0}},
+        {<<"MinDampStrengthY">>, {double, 0.0}},
+        {<<"MinDampStrengthZ">>, {double, 0.0}},
+        {<<"MaxDampStrengthX">>, {double, 0.0}},
+        {<<"MaxDampStrengthY">>, {double, 0.0}},
+        {<<"MaxDampStrengthZ">>, {double, 0.0}},
+        {<<"PreferedAngleX">>, {double, 0.0}},
+        {<<"PreferedAngleY">>, {double, 0.0}},
+        {<<"PreferedAngleZ">>, {double, 0.0}},
+        {<<"LookAtProperty">>, {object}},
+        {<<"UpVectorProperty">>, {object}},
+        {<<"Show">>, {bool, 1}},
+        {<<"NegativePercentShapeSupport">>, {bool, 1}},
+        {<<"DefaultAttributeIndex">>, {int, -1}},
+        {<<"Freeze">>, {bool, 0}},
+        {<<"LODBox">>, {bool, 0}},
+        {<<"Lcl Translation">>, {lcltranslation, 0.0, 0.0, 0.0}},
+        {<<"Lcl Rotation">>, {lclrotation, 0.0, 0.0, 0.0}},
+        {<<"Lcl Scaling">>, {lclscaling, 1.0, 1.0, 1.0}},
+        {<<"Visibility">>, {visibility, 1.0}},
+        {<<"Visibility Inheritance">>, {visibility_inheritance, 1}}
+    ].
+
+
+map_attr_dflo(#fopt{compress=true},L) ->
+    [{{deflate, attr_dflo_list}, L}];
+map_attr_dflo(_, L) ->
+    [{attr_dflo_list, L}].
+
+map_attr_int(#fopt{compress=true},L) ->
+    [{{deflate, attr_int_list}, L}];
+map_attr_int(_,L) ->
+    [{attr_int_list, L}].
+    
+layer(L_Normals, L_Binormals, L_Tangents, L_Smoothing, L_UV, L_Materials) ->
+    D1 =
+        [<<"Layer">>, [{attr_int, 0}],
+            [<<"Version">>, [{attr_int, ?FBX_OBJECTS_MODEL_LAYER_VERSION}]]
+        ],
+    L_No = if length(L_Normals) > 0 ->
+            [[<<"LayerElement">>, [],
+                [<<"Type">>, [{attr_str, <<"LayerElementNormal">>}]],
+                [<<"TypedIndex">>, [{attr_int, 0}]]
+            ]];
+            true -> []
+    end,
+    L_Nb = if length(L_Binormals) > 0 ->
+            [[<<"LayerElement">>, [],
+                [<<"Type">>, [{attr_str, <<"LayerElementBinormal">>}]],
+                [<<"TypedIndex">>, [{attr_int, 0}]]
+            ]];
+            true -> []
+    end,
+    L_Nt = if length(L_Tangents) > 0 ->
+            [[<<"LayerElement">>, [],
+                [<<"Type">>, [{attr_str, <<"LayerElementTangents">>}]],
+                [<<"TypedIndex">>, [{attr_int, 0}]]
+            ]];
+            true -> []
+    end,
+    L_Sm = if length(L_Smoothing) > 0 ->
+            [[<<"LayerElement">>, [],
+                [<<"Type">>, [{attr_str, <<"LayerElementSmoothing">>}]],
+                [<<"TypedIndex">>, [{attr_int, 0}]]
+            ]];
+            true -> []
+    end,
+    L_M = if length(L_Materials) > 0 ->
+            [[<<"LayerElement">>, [],
+                [<<"Type">>, [{attr_str, <<"LayerElementMaterial">>}]],
+                [<<"TypedIndex">>, [{attr_int, 0}]]
+            ]];
+            true -> []
+    end,
+    L_U = if length(L_UV) > 0 -> 
+            [[<<"LayerElement">>, [],
+                [<<"Type">>, [{attr_str, <<"LayerElementUV">>}]],
+                [<<"TypedIndex">>, [{attr_int, 0}]]
+            ]];
+            true -> []
+    end,
+    D1 ++ L_No ++ L_Nb ++ L_Nt ++ L_Sm ++ L_M ++ L_U.
+
+
+%% Turn list of tuples to Vertices list
+%%
+tuplelist_to_numbers(List) ->
+    tuplelist_to_numbers(List, []).
+tuplelist_to_numbers([{X,Y,Z}|L], OL) ->
+    tuplelist_to_numbers(L, [Z,Y,X|OL]);
+tuplelist_to_numbers([], OL) ->
+    lists:reverse(OL).
+
+
+%% Turn list of tuples to UV list
+%%
+tuplelist2_to_numbers(List) ->
+    tuplelist2_to_numbers(List, []).
+tuplelist2_to_numbers([{X,Y}|L], OL) ->
+    tuplelist2_to_numbers(L, [Y,X|OL]);
+tuplelist2_to_numbers([], OL) ->
+    lists:reverse(OL).
+
+
+%% Turn list of lists to PolygonVertexIndex list
+%%
+lists_to_polyvtxi(List) ->
+    lists_to_polyvtxi(List, []).
+lists_to_polyvtxi([List|L], OL) ->
+    [A|B] = lists:reverse(List),
+    List_1 = [((-A)-1)|B],
+    lists_to_polyvtxi(L, [List_1|OL]);
+lists_to_polyvtxi([], OL) ->
+    lists:reverse(lists:flatten(OL)).
+
+
+object_mesh_geom(FbxOpt, OID, Name, Props, Vertices, PolygonVertexIndex, Normals, Binormals, Tangents, UV, UVIndex, Materials, Edges) ->
+
+    L_UV = case UV of [] -> []; _ ->
+        [[<<"LayerElementUV">>, [{attr_int, 0}],
+            [<<"Version">>, [{attr_int, ?FBX_OBJECTS_MODEL_LAYERELEMENT_VERSION}]],
+            [<<"Name">>, [{attr_str, <<>>}]],
+            [<<"MappingInformationType">>, [{attr_str, <<"ByPolygonVertex">>}]],
+            [<<"ReferenceInformationType">>, [{attr_str, <<"IndexToDirect">>}]],
+            [<<"UV">>, map_attr_dflo(FbxOpt, tuplelist2_to_numbers(UV))],
+            [<<"UVIndex">>, map_attr_int(FbxOpt, lists:append(UVIndex))]
+        ]]
+    end,
+    L_Normals = case Normals of [] -> []; _ ->
+        [[<<"LayerElementNormal">>, [{attr_int, 0}],
+            [<<"Version">>, [{attr_int, ?FBX_OBJECTS_MODEL_LAYERELEMENT_VERSION}]],
+            [<<"Name">>, [{attr_str, <<>>}]],
+            [<<"MappingInformationType">>, [{attr_str, <<"ByPolygonVertex">>}]],
+            [<<"ReferenceInformationType">>, [{attr_str, <<"Direct">>}]],
+            [<<"Normals">>, map_attr_dflo(FbxOpt, tuplelist_to_numbers(Normals))] %,
+            % [<<"NormalsW">>, map_attr_int(FbxOpt, [1 || _ <- Normals])]
+        ]]
+    end,
+    L_Binormals = case Binormals of [] -> [] %% TODO: Later
+    end,
+    L_Tangents = case Tangents of [] -> [] %% TODO: Later
+    end,
+    Smoothing = [Sm || {_,Sm} <- Edges],
+    L_Smoothing = 
+        [[<<"LayerElementSmoothing">>, [{attr_int, 0}],
+            [<<"Version">>, [{attr_int, ?FBX_OBJECTS_MODEL_LAYERELEMENT_VERSION}]],
+            [<<"Name">>, [{attr_str, <<>>}]],
+            [<<"MappingInformationType">>, [{attr_str, <<"ByEdge">>}]],
+            [<<"ReferenceInformationType">>, [{attr_str, <<"Direct">>}]],
+            [<<"Smoothing">>, map_attr_int(FbxOpt, Smoothing)]
+        ]],
+
+    L_Materials = case Materials of [] -> []; _ ->
+        Materials_U = lists:usort(Materials),
+        OneMat = case Materials_U of [_] -> true; _ -> false end,
+        [[<<"LayerElementMaterial">>, [{attr_int, 0}],
+            [<<"Version">>, [{attr_int, ?FBX_OBJECTS_MODEL_LAYERELEMENT_VERSION}]],
+            [<<"Name">>, [{attr_str, <<>>}]],
+            [<<"MappingInformationType">>, [{attr_str, if OneMat -> <<"AllSame">>; true -> <<"ByPolygon">> end}]],
+            [<<"ReferenceInformationType">>, [{attr_str, <<"IndexToDirect">>}]],
+            [<<"Materials">>, map_attr_int(FbxOpt, if OneMat -> Materials_U; true -> Materials end)]
+        ]]
+    end,
+    
+    UEdges = [UIdx || {UIdx,_} <- Edges],
+
+    [<<"Geometry">>, [{attr_int64, OID}, {attr_str, Name}, {attr_str, <<"Mesh">>}],
+        proplist_to_properties70(Props),
+        
+        [<<"Vertices">>, map_attr_dflo(FbxOpt, tuplelist_to_numbers(Vertices))],
+        [<<"PolygonVertexIndex">>, map_attr_int(FbxOpt, lists_to_polyvtxi(PolygonVertexIndex))],
+        [<<"Edges">>, map_attr_int(FbxOpt, UEdges)],
+        [<<"GeometryVersion">>, [{attr_int, ?FBX_GEOMETRY_VERSION}]]
+        ] ++ L_Normals ++ L_Binormals ++ L_Tangents ++ L_Smoothing ++ L_UV ++ L_Materials ++ [
+        layer(L_Normals, L_Binormals, L_Tangents, L_Smoothing, L_UV, L_Materials)
+    ].
+
+
+%% Calculate list of unique edges
+%%    
+uedge_list(PolygonVIdx, HEs_0) ->
+    HEs = gb_sets:from_list(HEs_0),
+    uedge_list(PolygonVIdx, HEs, []).
+uedge_list([[C|[B2|_]=L]|R], HEs, OL) ->
+    OL_1 = uedge_list_1(C, L, [{C,B2}|OL]),
+    uedge_list(R, HEs, OL_1);
+uedge_list([], HEs, OL) ->
+    uedge_list_2(lists:reverse(OL), HEs).
+uedge_list_1(F, [C|[B2|_]=L], OL) ->
+    uedge_list_1(F, L, [{C,B2}|OL]);
+uedge_list_1(F, [C], OL) ->
+    [{C,F}|OL].
+uedge_list_2(Edges, HEs) ->
+    uedge_list_2(Edges, HEs, 0, #{}, []).
+uedge_list_2([{A1,A2}|R], HEs, Idx, Seen, OL) ->
+    {OL_1, Seen_1} =
+        case maps:is_key({A1,A2},Seen) orelse
+             maps:is_key({A2,A1},Seen)
+        of
+            true ->
+                {OL, Seen};
+            false ->
+                Sm = case gb_sets:is_member({A1,A2}, HEs) orelse
+                          gb_sets:is_member({A2,A1}, HEs) of
+                    true -> 0;
+                    false -> 1
+                end,
+                {[{Idx,Sm}|OL],Seen#{ {A1,A2} => 1 }}
+        end,
+    uedge_list_2(R, HEs, Idx+1, Seen_1, OL_1);
+uedge_list_2([], _, _Idx, _Seen, OL) ->
+    lists:reverse(OL).
+
+
+object_mesh_model(OID, Name, Props) ->
+
+    [<<"Model">>, [{attr_int64, OID}, {attr_str, Name}, {attr_str, <<"Mesh">>}],
+        [<<"Version">>, [{attr_int, ?FBX_OBJECTS_MODEL_VERSION}]],
+        proplist_to_properties70(Props),
+        [<<"Culling">>, [{attr_str, <<"CullingOff">>}]]
+    ].
+
+
+phong_material(MID, Name, Props) ->
+    [<<"Material">>, [{attr_int64, MID}, {attr_str, Name}, {attr_str, ""}],
+            [<<"Version">>, [{attr_int, ?FBX_OBJECTS_MATERIAL_VERSION}]],
+            [<<"ShadingModel">>, [{attr_str, "phong"}]],
+            [<<"MultiLayer">>, [{attr_int, 0}]],
+            proplist_to_properties70(Props)
+    ].
+
+default_properties70_video() ->
+    [
+        {<<"Width">>, {int, 0}},
+        {<<"Height">>, {int, 0}},
+        {<<"Path">>, {kstring, <<"">>}},
+        {<<"RelPath">>, {kstring, <<"">>}},
+        {<<"AccessMode">>, {enum, 0}},
+        {<<"FrameRate">>, {double, 0.0}},
+        {<<"FreeRunning">>, {bool, 0}},
+        {<<"ImageSequence">>, {bool, 0}},
+        {<<"ImageSequenceOffset">>, {int, 0}},
+        {<<"InterlaceMode">>, {enum, 0}},
+        {<<"LastFrame">>, {int, 0}},
+        {<<"Loop">>, {bool, 0}},
+        {<<"Offset">>, {ktime, 0}},
+        {<<"PlaySpeed">>, {double, 1.0}},
+        {<<"StartFrame">>, {int, 0}},
+        {<<"StopFrame">>, {int, 0}}
+    ].
+object_video(VID, Name, Props, FilenameOnly, RelativePath) ->
+    [<<"Video">>, [{attr_int64, VID}, {attr_str, Name}, {attr_str, <<"Clip">>}],
+        [<<"Type">>, [{attr_str, <<"Clip">>}]],
+        proplist_to_properties70(
+            [
+                {<<"Path">>, {kstring, FilenameOnly}}
+            ] ++ Props),
+        [<<"UseMipMap">>, [{attr_int, 0}]],
+        [<<"Filename">>, [{attr_str, FilenameOnly}]],
+        [<<"RelativeFilename">>, [{attr_str, RelativePath}]]
+    ].
+
+default_properties70_texture() ->
+    [
+        {<<"PremultiplyAlpha">>, {bool, 1}},
+        {<<"UVSet">>, {kstring, <<"default">>}},
+        {<<"Translation">>, {vectex, 0.0, 0.0, 0.0}},
+        {<<"Rotation">>, {vectex, 0.0, 0.0, 0.0}},
+        {<<"Scaling">>, {vectex, 1.0, 1.0, 1.0}},
+        {<<"Texture alpha">>, {number, 1.0}},
+        {<<"TextureTypeUse">>, {enum, 0}},
+        {<<"CurrentTextureBlendMode">>, {enum, 1}},
+        {<<"UseMaterial">>, {bool, 1}},
+        {<<"UseMipMap">>, {bool, 0}},
+        {<<"CurrentMappingType">>, {enum, 0}},
+        {<<"UVSwap">>, {bool, 0}},
+        {<<"WrapModeU">>, {enum, 0}},
+        {<<"WrapModeV">>, {enum, 0}},
+        {<<"TextureRotationPivot">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"TextureScalingPivot">>, {vec3d, 0.0, 0.0, 0.0}},
+        {<<"VideoProperty">>, {object}}
+    ].
+object_texture(TID, Name, Props, FilenameOnly, RelativePath)
+  when is_integer(TID) ->
+    [<<"Texture">>, [{attr_int64, TID}, {attr_str, Name}, {attr_str, "TextureVideoClip"}],
+        [<<"Type">>, [{attr_str, <<"TextureVideoClip">>}]],
+        [<<"Version">>, [{attr_int, 202}]],
+        [<<"TextureName">>, [{attr_str, FilenameOnly}]],
+        proplist_to_properties70(Props),
+        [<<"Media">>, [{attr_str, FilenameOnly}]],
+        [<<"FileName">>, [{attr_str, FilenameOnly}]],
+        [<<"RelativeFilename">>, [{attr_str, RelativePath}]],
+        [<<"ModelUVTranslation">>, [{attr_dflo, 0.0}, {attr_dflo, 0.0}]],
+        [<<"ModelUVScaling">>, [{attr_dflo, 1.0}, {attr_dflo, 1.0}]],
+        [<<"Texture_Alpha_Source">>, [{attr_str, <<"None">>}]],
+        [<<"Cropping">>, [{attr_int, 0}, {attr_int, 0}, {attr_int, 0}, {attr_int, 0}]]
+    ].
+
+
+
+fbx_form_definitions(Geoms, Models, Mats, Texs, Vids)
+  when is_list(Geoms),
+       is_list(Models),
+       is_list(Mats),
+       is_list(Texs),
+       is_list(Vids) ->
+    Geoms_Len = length(Geoms),
+    Models_Len = length(Models),
+    Mats_Len = length(Mats),
+    Texs_Len = length(Texs),
+    Vids_Len = length(Vids),
+    Total = Geoms_Len + Models_Len + Mats_Len + Texs_Len + Vids_Len + 1,
+    D0 =
+        [<<"Definitions">>, [],
+            [<<"Version">>, [{attr_int, ?FBX_DEFINITIONS_VERSION}]],
+            [<<"Count">>, [{attr_int, Total}]],
+            [<<"ObjectType">>, [{attr_str, <<"GlobalSettings">>}],
+                [<<"Count">>, [{attr_int, 1}]]
+            ]
+        ],
+
+    D_G = if Geoms_Len > 0 ->
+                [[<<"ObjectType">>, [{attr_str, <<"Geometry">>}],
+                    [<<"Count">>, [{attr_int, Geoms_Len}]],
+                    [<<"PropertyTemplate">>, [{attr_str, <<"FbxMesh">>}],
+                        proplist_to_properties70(default_properties70_geometry())
+                    ]
+                ]];
+            true -> []
+    end,
+    D_Mo = if Models_Len > 0 ->
+                [[<<"ObjectType">>, [{attr_str, <<"Model">>}],
+                    [<<"Count">>, [{attr_int, Models_Len}]],
+                    [<<"PropertyTemplate">>, [{attr_str, <<"FbxNode">>}], 
+                        proplist_to_properties70(default_properties70_object())
+                    ]
+                ]];
+            true -> []
+    end,
+    D_Ma = if Mats_Len > 0 ->
+                [[<<"ObjectType">>, [{attr_str, <<"Material">>}],
+                    [<<"Count">>, [{attr_int, Mats_Len}]],
+                    [<<"PropertyTemplate">>, [{attr_str, <<"FbxSurfacePhong">>}],
+                        proplist_to_properties70(default_properties70_material())
+                    ]
+                ]];
+            true -> []
+    end,
+    D_Tx = if Texs_Len > 0 ->
+                [[<<"ObjectType">>, [{attr_str, <<"Texture">>}],
+                    [<<"Count">>, [{attr_int, Texs_Len}]],
+                    [<<"PropertyTemplate">>, [{attr_str, <<"FbxFileTexture">>}],
+                        proplist_to_properties70(default_properties70_texture())
+                    ]
+                ]];
+            true -> []
+    end,
+    D_Vd = if Vids_Len > 0 ->
+                [[<<"ObjectType">>, [{attr_str, <<"Video">>}],
+                    [<<"Count">>, [{attr_int, Vids_Len}]],
+                    [<<"PropertyTemplate">>, [{attr_str, <<"FbxVideo">>}],
+                        proplist_to_properties70(default_properties70_video())
+                    ]
+                ]];
+            true -> []
+    end,
+    D0 ++ D_G ++ D_Mo ++ D_Ma ++ D_Tx ++ D_Vd.
+
+fbx_form_header_ext_creation_time_stamp(CreationTime) ->
+    Year = str_to_num(string:sub_string(CreationTime, 1+0, 4)),
+    Month = str_to_num(string:sub_string(CreationTime, 1+5, 7)),
+    Day = str_to_num(string:sub_string(CreationTime, 1+8, 10)),
+    Hour = str_to_num(string:sub_string(CreationTime, 1+11, 13)),
+    Minute = str_to_num(string:sub_string(CreationTime, 1+14, 16)),
+    Second = str_to_num(string:sub_string(CreationTime, 1+17, 19)),
+    Millisecond = str_to_num(string:sub_string(CreationTime, 1+20, 23)),
+    [<<"CreationTimeStamp">>, [],
+        [<<"Version">>, [{attr_int, 1000}]],
+        [<<"Year">>, [{attr_int, Year}]],
+        [<<"Month">>, [{attr_int, Month}]],
+        [<<"Day">>, [{attr_int, Day}]],
+        [<<"Hour">>, [{attr_int, Hour}]],
+        [<<"Minute">>, [{attr_int, Minute}]],
+        [<<"Second">>, [{attr_int, Second}]],
+        [<<"Millisecond">>, [{attr_int, Millisecond}]] 
+    ].
+
+fbx_form_header_ext(CreationTool, CreationTime, TimeSaved) ->
+    WingsName = <<"Wings3D">>,
+    WingsVersion = <<"1.0">>,
+    [<<"FBXHeaderExtension">>, [],
+        [<<"FBXHeaderVersion">>, [{attr_int, 1003}]],
+        [<<"FBXVersion">>, [{attr_int, ?FBX_VERSION}]],
+        [<<"EncryptionType">>, [{attr_int, 0}]],
+        fbx_form_header_ext_creation_time_stamp(CreationTime),
+        [<<"Creator">>, [{attr_str, CreationTool}]],
+        [<<"SceneInfo">>, [{attr_str, name_type_pair(<<"GlobalInfo">>,<<"SceneInfo">>)},{attr_str,<<"UserData">>}],
+            [<<"Type">>, [{attr_str, <<"UserData">>}]],
+            [<<"Version">>, [{attr_int, 100}]],
+            [<<"MetaData">>, [],
+                [<<"Version">>, [{attr_int,100}]],
+                [<<"Title">>, [{attr_str, <<"">>}]],
+                [<<"Subject">>, [{attr_str, <<"">>}]],
+                [<<"Author">>, [{attr_str, <<"">>}]],
+                [<<"Keywords">>, [{attr_str, <<"">>}]],
+                [<<"Revision">>, [{attr_str, <<"">>}]],
+                [<<"Comment">>, [{attr_str, <<"">>}]]
+            ],
+            proplist_to_properties70([
+                {<<"DocumentUrl">>, {kstring, <<>>}},
+                {<<"SrcDocumentUrl">>, {kstring, <<>>}},
+                {<<"Original">>, {compound}},
+                {<<"Original|ApplicationVendor">>, {kstring, WingsName}},
+                {<<"Original|ApplicationName">>, {kstring, WingsName}},
+                {<<"Original|ApplicationVersion">>, {kstring, WingsVersion}},
+                {<<"Original|DateTime_GMT">>, {datetime, TimeSaved}},
+                {<<"Original|FileName">>, {kstring, <<>>}},
+                {<<"LastSaved">>, {compound}},
+                {<<"LastSaved|ApplicationVendor">>, {kstring, WingsName}},
+                {<<"LastSaved|ApplicationName">>, {kstring, WingsName}},
+                {<<"LastSaved|ApplicationVersion">>, {kstring, WingsVersion}},
+                {<<"LastSaved|DateTime_GMT">>, {datetime, TimeSaved}}
+            ])
+        ]
+    ].
+
+fbx_form_global_settings() ->
+    [<<"GlobalSettings">>, [],
+        [<<"Version">>, [{attr_int, 1000}]],
+        proplist_to_properties70([
+            {<<"UpAxis">>, {int, 1}},
+            {<<"UpAxisSign">>, {int, 1}},
+            {<<"FrontAxis">>, {int, 2}},
+            {<<"FrontAxisSign">>, {int, 1}},
+            {<<"CoordAxis">>, {int, 0}},
+            {<<"CoordAxisSign">>, {int, 1}},
+            {<<"OriginalUpAxis">>, {int, -1}},
+            {<<"OriginalUpAxisSign">>, {int, 1}},
+            {<<"UnitScaleFactor">>, {double, 1.0}},
+            {<<"OriginalUnitScaleFactor">>, {double, 1.0}},
+            {<<"AmbientColor">>, {color_rgb, 0.0, 0.0, 0.0}},
+            {<<"DefaultCamera">>, {kstring, <<"Producer Perspective">>}},
+            {<<"TimeMode">>, {enum, 0}},
+            {<<"TimeSpanStart">>, {ktime, 0}},
+            {<<"TimeSpanStop">>, {ktime, 1000}},
+            {<<"CustomFrameRate">>, {double, 24.0}}
+        ])
+    ].
+
+
+
+obj_vs(Obj) ->
+    proplists:get_value(vertices, Obj, false).
+obj_faces(Obj) ->
+    proplists:get_value(vtxindex, Obj, false).
+obj_ns(Obj) ->
+    proplists:get_value(ns, Obj, false).
+obj_uv(Obj) ->
+    proplists:get_value(uv, Obj, false).
+obj_uvidx(Obj) ->
+    proplists:get_value(uvidx, Obj, false).
+obj_mats(Obj) ->
+    proplists:get_value(mats, Obj, false).
+obj_edges(Obj) ->
+    proplists:get_value(edges, Obj, false).
+
+    
+object_mesh_model_props(A) ->
+    RotationPivot = proplists:get_value(rotation_pivot, A, false),
+    ScalingPivot = proplists:get_value(scaling_pivot, A, false),
+    D1 = object_mesh_model_props_rpiv(RotationPivot),
+    D2 = object_mesh_model_props_spiv(ScalingPivot),
+    D1 ++ D2 ++ [
+        %% Have our model rescaled from 0.0 ... 1.0 to 0.0 ... 100.0
+        {<<"Lcl Scaling">>, {lclscaling,100.0,100.0,100.0}}
+    ].
+
+    
+object_mesh_model_props_rpiv([X,Y,Z]) ->
+    [ {<<"RotationPivot">>, {vec3d,float(X),float(Y),float(Z)}} ];
+object_mesh_model_props_rpiv(false) ->
+    [].
+
+
+object_mesh_model_props_spiv([X,Y,Z]) ->
+    [ {<<"ScalingPivot">>, {vec3d, float(X), float(Y), float(Z)}} ];
+object_mesh_model_props_spiv(false) ->
+    [].
+
+
+obj_filename_only(Obj) ->
+    %% Only the filename without a path ("todo.bmp")
+    proplists:get_value(filename_only, Obj, false).
+    
+obj_relative_path(Obj) ->
+    %% Relative path on the file system ("..\\ASCII\\todo.bmp")
+    proplists:get_value(relative_path, Obj, false).
+    
+    
+object_texture_props(_A) ->
+    [].
+object_video_props(A) ->
+    FilenameOnly = obj_filename_only(A),
+    [
+        {<<"Path">>, {kstring, FilenameOnly}}
+    ].
+    
+phong_material_props(A) ->
+    Props = proplists:get_value(prop, A, []),
+    Props.
+
+fbx_form_objects(FbxOpt, Geoms, Models, Mats, Texs, Vids) ->
+    D_G = 
+        [
+            object_mesh_geom(FbxOpt, OID, NameTypePair,
+                object_mesh_model_props(A),
+                obj_vs(A),
+                obj_faces(A),
+                obj_ns(A),
+                [], [],
+                obj_uv(A),
+                obj_uvidx(A),
+                obj_mats(A),
+                obj_edges(A))
+        || {_OType, {OID, NameTypePair, _}, A} <- Geoms ],
+    D_Mo =
+        [
+            case OType of
+                model ->
+                    object_mesh_model(OID, NameTypePair,
+                        object_mesh_model_props(A))
+            end
+        || {OType, {OID, NameTypePair, _}, A} <- Models ],
+    D_Ma = [
+            phong_material(MID, NameTypePair,
+                phong_material_props(A))
+        || {mat, {MID, NameTypePair, _}, A} <- Mats],
+    D_Tx = [
+            object_texture(TID, NameTypePair,
+                object_texture_props(A),
+                obj_filename_only(A),
+                obj_relative_path(A))
+        || {tex, {for, _, {TID, NameTypePair, _}}, A} <- Texs],
+    D_Vd = [
+            object_video(VID, NameTypePair,
+                object_video_props(A),
+                obj_filename_only(A),
+                obj_relative_path(A))
+        || {video, {VID, NameTypePair, _}, A} <- Vids],
+    
+    {<<"Objects">>, [], D_G ++ D_Mo ++ D_Ma ++ D_Tx ++ D_Vd}.
+
+
+%% Build list of connections between videos and textures.
+%%
+connections_to_textures(Texs) ->
+    D4_0 = lists:map( fun connections_to_textures_1/1, Texs),
+    D4 = lists:append(D4_0),
+    D4.
+connections_to_textures_1({_,{for,_,{TID, _,_}},R})
+  when is_integer(TID) ->
+    connections_to_textures_1(TID,R,[]).
+connections_to_textures_1(TID,[{{video,{VID,_,_}},_}|R],OL)
+  when is_integer(TID),is_integer(VID) ->
+    %% Videos that connect to textures
+    OL_1 = [{oo, VID, TID} |OL],
+    connections_to_textures_1(TID,R,OL_1);
+connections_to_textures_1(TID,[_|R],OL) ->
+    connections_to_textures_1(TID,R,OL);
+connections_to_textures_1(_TID,[],OL) ->
+    lists:reverse(OL).
+
+
+%% Build list of connections between textures and materials.
+%%
+connections_to_materials(Texs, Mats) ->
+    D4 = connections_to_textures(Texs),
+    D3_0 = lists:map( fun connections_to_materials_1/1, Mats),
+    D3 = lists:append(D3_0),
+    D3 ++ D4.
+connections_to_materials_1({_,{OID, OName, _},R})
+  when is_integer(OID) ->
+    connections_to_materials_1(OID, OName, R, []).
+connections_to_materials_1(OID, OName, [{{tex, {for, Which, {TID,_,_}}}, _}|R], OL)
+  when is_integer(TID) ->
+    %% Textures that connect to materials
+    OL_1 = [{op, TID, OID, Which}|OL],
+    connections_to_materials_1(OID, OName, R, OL_1);
+connections_to_materials_1(_OID, _OName, [{{tex, _}, _}=_A|_R], _OL) ->
+    error(unexpected);
+connections_to_materials_1(OID, OName, [_|R], OL) ->
+    connections_to_materials_1(OID, OName, R, OL);
+connections_to_materials_1(_OID, _OName, [], OL) ->
+    lists:reverse(OL).
+
+
+%% Build list of connections from geometries and materials
+%% to models.
+%%
+connections_to_models(Models) ->
+    D2_0 = lists:map( fun connections_to_models_1/1, Models),
+    D2 = lists:append(D2_0),
+    D2.
+connections_to_models_1({_,{OID,OName,_},R})
+  when is_integer(OID) ->
+    connections_to_models_1(OID,OName,R,[]).
+connections_to_models_1(OID,OName,[{{mat, {MID,_,_}}, _}|R],OL)
+  when is_integer(MID) ->
+    %% Materials that connect to Models
+    OL_1 = [{oo, MID, OID} | OL],
+    connections_to_models_1(OID,OName,R,OL_1);
+connections_to_models_1(OID,OName,[{{geom, {MID,_,_}},_}|R],OL)
+  when is_integer(MID) ->
+    %% Geometries that connect to Models
+    OL_1 = [{oo, MID, OID} | OL],
+    connections_to_models_1(OID,OName,R,OL_1);
+connections_to_models_1(OID,OName,[_|R],OL) ->
+    connections_to_models_1(OID,OName,R,OL);
+connections_to_models_1(_OID,_OName,[],OL) ->
+    lists:reverse(OL).
+
+
+%% Build list of connections between models and the root node.
+%%
+connections_to_root_node(Models) ->
+    %% Models that connect to Scene
+    D1 = [ {oo, OID, 0}
+        || {_,{OID, _OName, _},_} <- Models],
+    D1.
+
+
+fbx_form_connections(CL) ->
+
+    D1 = lists:map(
+            fun
+                ({oo,OID1,OID2})
+                  when is_integer(OID1), is_integer(OID2) ->
+                    [<<"C">>, [<<"OO">>,
+                        {attr_int64, OID1},
+                        {attr_int64, OID2}]
+                    ];
+                ({op,OID1,OID2,Kind})
+                  when is_integer(OID1), is_integer(OID2), is_binary(Kind) ->
+                    [<<"C">>, [<<"OP">>,
+                        {attr_int64, OID1},
+                        {attr_int64, OID2},
+                        {attr_str, Kind}]
+                    ]
+            end, CL),
+    
+    {<<"Connections">>, [], D1}.
+
+
+%%% Break out elements out of other elements for FBX's structure.
+%%%
+
+%% Break out videos from textures.
+%%
+textures_objects(Texs,IdAMap) ->
+    textures_objects(Texs,IdAMap,[],[]).
+textures_objects([T|Texs],IdAMap,OL,O2) ->
+    {Vids, T_1,IdAMap_1} = textures_objects_1(T,IdAMap),
+    textures_objects(Texs,IdAMap_1,[Vids|OL],[T_1|O2]);
+textures_objects([],IdAMap,OL,O2) ->
+    Vids = lists:append(lists:reverse(OL)),
+    Texs = lists:reverse(O2),
+    {Vids,Texs,IdAMap}.
+textures_objects_1({Kind,{for,Which,{TID, _,_}=Ident},R},IdAMap)
+  when is_integer(TID) ->
+    {R_1, IdAMap_1} = add_ident_numbers(R, IdAMap),
+    {Vids, R_2} = textures_objects_1(TID,R_1,[],[]),
+    {Vids, {Kind,{for,Which,Ident},R_2}, IdAMap_1}.
+textures_objects_1(TID,[{{video,Ident},VI}|R],OL,O2) ->
+    %% Videos that connect to Textures
+    OL_1 = [{video,Ident,VI} |OL],
+    O2_1 = [{{video,Ident},vid}|O2],
+    textures_objects_1(TID,R,OL_1,O2_1);
+textures_objects_1(TID,[E|R],OL,O2) ->
+    O2_1 = [E|O2],
+    textures_objects_1(TID,R,OL,O2_1);
+textures_objects_1(_TID,[],OL,O2) ->
+    {lists:reverse(OL), lists:reverse(O2)}.
+
+
+
+%% Break out videos, textures from materials.
+%%
+materials_objects(Mats,IdAMap) ->
+    materials_objects(Mats,IdAMap,[],[],[]).
+materials_objects([M|Mats],IdAMap,OV,OL,O2) ->
+    {Texs_0, M_1, IdAMap_1} = materials_objects_1(M, IdAMap),
+    {Vids, Texs, IdAMap_2} = textures_objects(Texs_0, IdAMap_1),
+    materials_objects(Mats,IdAMap_2,[Vids|OV],[Texs|OL],[M_1|O2]);
+materials_objects([],IdAMap,OV,OL,O2) ->
+    Vids = lists:append(lists:reverse(OV)),
+    Texs = lists:append(lists:reverse(OL)),
+    Mats = lists:reverse(O2),
+    { Vids, Texs, Mats, IdAMap}.
+materials_objects_1({Kind,{OID, OName, _}=Ident,R},IdAMap)
+  when is_integer(OID) ->
+    {R_1, IdAMap_1} = add_ident_numbers(R, IdAMap),
+    {Texs, R_2} = materials_objects_1(OID, OName, R_1, [],[]),
+    {Texs, {Kind,Ident,R_2},IdAMap_1}.
+materials_objects_1(OID, OName, [{{tex, Ident}, Tx}|R], OL, O2) ->
+    %% Textures that connect to Models
+    OL_1 = [{tex, Ident, Tx} |OL],
+    O2_1 = [{{tex, Ident}, tex}|O2],
+    materials_objects_1(OID, OName, R, OL_1,O2_1);
+materials_objects_1(OID, OName, [E|R], OL,O2) ->
+    O2_1 = [E|O2],
+    materials_objects_1(OID, OName, R, OL,O2_1);
+materials_objects_1(_OID, _OName, [], OL,O2) ->
+    {lists:reverse(OL), lists:reverse(O2)}.
+
+
+name_only(OName) ->
+    name_only(OName, []).
+name_only(<<C,OName/binary>>, OL)
+  when C =/= 0, C =/= 1 ->
+    name_only(OName, [C|OL]);
+name_only(_, OL) ->
+    lists:reverse(OL).
+
+
+%% Break out nested geometries in models
+%%
+mesh_objects(Models, IdAMap) ->
+    mesh_objects(Models, IdAMap, [], []).
+mesh_objects([M|Models], IdAMap, OL, O2) ->
+    {Geoms, M_1} = mesh_objects_1(M, IdAMap),
+    mesh_objects(Models, IdAMap, [Geoms|OL], [M_1|O2]);
+mesh_objects([], _IdAMap, OL, O2) ->
+    Geoms = lists:append(lists:reverse(OL)),
+    Models = lists:reverse(O2),
+    {Geoms, Models}.
+mesh_objects_1({Kind,{OID,OName,_}=Ident,R}, IdAMap)
+  when is_integer(OID) ->
+    {Geoms, R_1} = mesh_objects_1(OID, IdAMap,OName,R,[],[]),
+    {Geoms, {Kind,Ident,R_1}}.
+mesh_objects_1(OID,{ActualIdAMap,_}=IdAMap,OName,[{{mat, AtomIdent}, _}|R],OL,O2)
+  when is_atom(AtomIdent) ->
+    ActualIdent = maps:get(AtomIdent, ActualIdAMap),
+    OL_1 = OL,
+    O2_1 = [{{mat, ActualIdent}, mat}|O2],
+    mesh_objects_1(OID,IdAMap,OName,R,OL_1,O2_1);
+mesh_objects_1(OID,IdAMap,OName,[{geom, G}|R],OL,O2) ->
+    GID = OID+150000, % This should be okay
+    GName = name_only(OName) ++ "__geo",
+    Ident = {GID, name_type_pair(GName, <<"Geometry">>), <<"Geometry">>},
+    OL_1 = [{geom, Ident, G} | OL],
+    O2_1 = [{{geom, Ident}, geom}|O2],
+    mesh_objects_1(OID,IdAMap,OName,R,OL_1,O2_1);
+mesh_objects_1(OID,{_, _}=IdAMap,OName,[E|R],OL,O2) ->
+    O2_1 = [E|O2],
+    mesh_objects_1(OID,IdAMap,OName,R,OL,O2_1);
+mesh_objects_1(_OID,_IdAMap,_OName,[],OL,O2) ->
+    {lists:reverse(OL), lists:reverse(O2)}.
+
+date_time_to_strings({{Year,Mon,Day},{Hr,Min,Sec}}) ->
+    TimeSaved_0 = io_lib:format(
+        "~2..0w/~2..0w/~4..0w ~2..0w:~2..0w:~2..0w.~3..0w", [
+            Mon,Day,Year,Hr,Min,Sec,0
+        ]),
+    TimeSaved = iolist_to_binary(TimeSaved_0),
+    CreationTime_0 = io_lib:format(
+        "~4..0w-~2..0w-~2..0w ~2..0w:~2..0w:~2..0w.~3..0w", [
+        Year,Mon,Day,Hr,Min,Sec,0
+        ]),
+    CreationTime = lists:flatten(CreationTime_0),
+    {CreationTime, TimeSaved}.
+
+%% Assemble the different sections into an iolist
+fbx_form(FbxOpt, Objs0, Mats0, IdAMap) ->
+
+    {CreationTime, TimeSaved} = date_time_to_strings(erlang:localtime()),
+    CreationTool = "Wings3D FBX Plugin",
+    
+    %% These values seem random, but not sure.
+    FileID    = [
+        16#12,16#34,16#56,16#78,16#9A,16#BC,16#DE,16#FF,
+        16#11,16#22,16#33,16#44,16#55,16#66,16#77,16#88],
+    UUIDIsh_1 = FileID, % NOTE: This value is usually different from FileID
+    
+    %% This value always shows up the same in every FBX file
+    UUIDIsh_2 = [
+        16#F8,16#5A,16#8C,16#6A,16#DE,16#F5,16#D9,16#7E,
+        16#EC,16#E9,16#0C,16#E3,16#75,16#8F,16#29,16#0B],
+    
+    %% Separate the objects into geometries and models
+    %%
+    {Geoms, Models} = mesh_objects(Objs0, IdAMap),
+    
+    %% Separate the materials into materials, videos and textures
+    %%
+    {Vids, Texs, Mats, _} = materials_objects(Mats0, IdAMap),
+    
+    CL3 = connections_to_materials(Texs, Mats),
+    CL2 = connections_to_models(Models),
+    CL1 = connections_to_root_node(Models),
+    Connections = CL1 ++ CL2 ++ CL3,
+
+    {
+        [
+            fbx_form_header_ext(CreationTool, CreationTime, TimeSaved),
+            [<<"FileId">>, [{attr_data, FileID}]],
+            [<<"CreationTime">>, [{attr_str, CreationTime}]],
+            [<<"Creator">>, [{attr_str, CreationTool}]],
+            fbx_form_global_settings(),
+            fbx_form_definitions(Geoms, Models, Mats, Texs, Vids),
+            fbx_form_objects(FbxOpt, Geoms, Models, Mats, Texs, Vids),
+            fbx_form_connections(Connections)
+        ],
+        UUIDIsh_1, % UUID-ish 1
+        UUIDIsh_2  % UUID-ish 2
+    }.
+
+str_to_num(S) ->
+    list_to_integer(lists:flatten(S)).
+
+
+%% Write the completed iolist to file.
+%%
+write_fbx_file(Filename, FbxOpt, Objs, Mats, IdAMap) ->
+    {ok, Fo} = file:open(Filename,[write,binary]),
+    write_list(write_fbx(fbx_form(FbxOpt, Objs, Mats, IdAMap)), Fo),
+    file:close(Fo).
+
+
+fbx_type_from_atom(A) ->
+    case A of
+        model -> <<"Model">>;
+        mat -> <<"Material">>;
+        tex -> <<"Texture">>;
+        video -> <<"Video">>
+    end.
+
+
+%% Assign numeric identifiers to all the elements (models, materials,
+%% textures).
+%%
+add_ident_numbers(Objs0) ->
+    add_ident_numbers(Objs0, #{}, 1000).
+add_ident_numbers(Objs0, {IdAMap, NextNumber}) ->
+    add_ident_numbers(Objs0, IdAMap, NextNumber).
+
+add_ident_numbers(Objs0, IdAMap, NextNumber) ->
+    add_ident_numbers(Objs0, IdAMap, NextNumber, []).
+add_ident_numbers([{A,B,C}|L], IdAMap, NextNumber, OL)
+  when is_atom(A),is_atom(B) ->
+    B_1 = atom_to_list(B),
+    NameTypePair = name_type_pair(B_1, fbx_type_from_atom(A)),
+    ActualIdent = {NextNumber,NameTypePair,A},
+    add_ident_numbers(
+        L,
+        IdAMap#{B => ActualIdent},
+        NextNumber+1,
+        [{A,ActualIdent,C}|OL]);
+add_ident_numbers([{A,B,C}|L], IdAMap, NextNumber, OL)
+  when is_atom(A),is_list(B) ->
+    B_1 = B,
+    NameTypePair = name_type_pair(B_1, fbx_type_from_atom(A)),
+    ActualIdent = {NextNumber,NameTypePair,A},
+    add_ident_numbers(
+        L,
+        IdAMap#{B => ActualIdent},
+        NextNumber+1,
+        [{A,ActualIdent,C}|OL]);
+
+add_ident_numbers([{{A,B},C}|L], IdAMap, NextNumber, OL)
+  when is_atom(A),is_atom(B) ->
+    B_1 = atom_to_list(B),
+    NameTypePair = name_type_pair(B_1, fbx_type_from_atom(A)),
+    ActualIdent = {NextNumber,NameTypePair,A},
+    add_ident_numbers(
+        L,
+        IdAMap#{B => ActualIdent},
+        NextNumber+1,
+        [{{A,ActualIdent},C}|OL]);
+add_ident_numbers([{{A,B},C}|L], IdAMap, NextNumber, OL)
+  when is_atom(A),is_list(B) ->
+    B_1 = B,
+    NameTypePair = name_type_pair(B_1, fbx_type_from_atom(A)),
+    ActualIdent = {NextNumber,NameTypePair,A},
+    add_ident_numbers(
+        L,
+        IdAMap#{B => ActualIdent},
+        NextNumber+1,
+        [{{A,ActualIdent},C}|OL]);
+
+add_ident_numbers([{{A,{for,Which,B}},C}|L], IdAMap, NextNumber, OL)
+  when is_atom(A),is_atom(B),is_binary(Which) ->
+    B_1 = atom_to_list(B),
+    NameTypePair = name_type_pair(B_1, fbx_type_from_atom(A)),
+    ActualIdent = {NextNumber,NameTypePair,A},
+    add_ident_numbers(
+        L,
+        IdAMap#{B => ActualIdent},
+        NextNumber+1,
+        [{{A,{for,Which,ActualIdent}},C}|OL]);
+add_ident_numbers([{{A,{for,Which,B}},C}|L], IdAMap, NextNumber, OL)
+  when is_atom(A),is_list(B),is_binary(Which) ->
+    B_1 = B,
+    NameTypePair = name_type_pair(B_1, fbx_type_from_atom(A)),
+    ActualIdent = {NextNumber,NameTypePair,A},
+    add_ident_numbers(
+        L,
+        IdAMap#{B => ActualIdent},
+        NextNumber+1,
+        [{{A,{for,Which,ActualIdent}},C}|OL]);
+
+add_ident_numbers([Other|L], IdAMap, NextNumber, OL) ->
+    add_ident_numbers(L,IdAMap,NextNumber,[Other|OL]);
+add_ident_numbers([], IdAMap, NextNumber, OL) ->
+    {lists:reverse(OL), {IdAMap, NextNumber}}.
+
+
+str_to_utf8b(A)
+  when is_list(A) ->
+    unicode:characters_to_nfc_binary(A);
+str_to_utf8b(A)
+  when is_binary(A) ->
+    A.
+
+
+
+%%%
